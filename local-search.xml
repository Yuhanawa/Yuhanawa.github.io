<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对Nostr协议的简单了解</title>
    <link href="/posts/2023/82b5/"/>
    <url>/posts/2023/82b5/</url>
    
    <content type="html"><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>N</strong>otes and <strong>O</strong>ther <strong>S</strong>tuff <strong>T</strong>ransmitted by <strong>R</strong>elays 2020年启动的去中心化社交网络开源协议, 是一个 <em>“极简可用”的去中心化社交协议</em> , 2022年推特创始人Jack对该项目进行了14BTC的捐助, 23年2月1日Jack宣布基于Nostr的应用Damus上线, 随后爆火, 圈内被大量公钥刷屏, 总体来说是一个非常有潜力的去中心化社交网络方案</p><h3 id="特点-amp-设计目标"><a href="#特点-amp-设计目标" class="headerlink" title="特点 &amp; 设计目标"></a>特点 &amp; 设计目标</h3><ol><li>去中心化:Nostr不依赖任何中心化服务器,整个网络由用户设备节点组成。这使得Nostr不容易被审查与封锁。</li><li>保护隐私:Nostr基于加密货币的零知识证明技术,可以隐藏用户的个人信息与社交数据。</li><li>数据所有权:Nostr让用户拥有并控制自己的数据。用户可以选择只与好友共享部分信息。</li><li>开放协议:Nostr是一个开源项目,协议细节透明公开,方便开发者基于Nostr开发新的应用。</li></ol><p>不必多说, 可以简要概括为<br>去中心化 抗审查 隐私安全<br>不需要你的任何信息, 没有任何限制, 没人能屏蔽你想知道的信息</p><h3 id="目前一些略有名气的客户端-Clients"><a href="#目前一些略有名气的客户端-Clients" class="headerlink" title="目前一些略有名气的客户端(Clients)"></a>目前一些略有名气的客户端(Clients)</h3><ul><li><p>IOS: </p><ul><li><a href="https://apps.apple.com/ca/app/damus/id1628663131">Damus</a> NOTE:因抗审查原因, 中国区已被下架</li></ul></li><li><p>Android: </p><ul><li><a href="https://play.google.com/store/apps/details?id=com.vitorpamplona.amethyst">Amethyst</a> </li><li><a href="https://github.com/KoalaSat/nostros/">NostrOS</a></li></ul></li><li><p>Web: </p><ul><li><a href="https://iris.to/">https://iris.to/</a></li><li><a href="https://snort.social/">https://snort.social/</a></li><li><a href="https://nostrgram.co/">https://nostrgram.co/</a></li><li><a href="https://astral.ninja/">https://astral.ninja/</a></li></ul></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在 Nostr 中没有中心服务器, 只有<code>relay</code> 和 <code>client</code>, relay 和 client 都可以自行实现  </p><ul><li>relay,中继器 数量不受限制,任何人都可以架设, 你可以<a href="https://nostr.watch/relays/find">在这里找到一些relays</a>  </li><li>client,客户端 同样不受限制</li></ul><p>其中relay与client通信, relays之间不互相通信    </p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>Nostr协议的实现并不困难,<a href="https://github.com/nostr-protocol/nips">完整协议在这里</a>, 每一条协议被称为NIP(Nostr Implementation Possibilty).</p><p>从 client 到 relay 支持三种操作:  </p><ul><li>EVENT: 发布 event,发布消息、修改个人简介等等</li><li>REQ：搜索数据、订阅 relay 的新信息,比如你关注的用户发布了信息,就可以通过这个请求获取到</li><li>CLOSE：关闭 REQ 操作中的订阅</li></ul><p>从 relay 到 client 支持两种操作：  </p><ul><li>EVENT: 返回用户订阅的 event 信息</li><li>NOTICE：返回可读的信息,这些信息的内容可以由 relay 自行决定</li></ul><p>详细内容可以参考 <a href="https://github.com/nostr-protocol/nips">NIPS</a> 以及 <a href="https://andreneves.xyz/p/set-up-a-nostr-relay-server-in-under">Set up a Nostr Relay server in under 5 minutes </a>  </p><h3 id="账号体系"><a href="#账号体系" class="headerlink" title="账号体系"></a>账号体系</h3><p><img src="/posts/2023/82b5/%E4%B8%8D%E8%A6%81%E7%9E%8E%E5%8F%91Nostr%E7%A7%81%E9%92%A5.jpg" alt="不要瞎发Nostr私钥_图片来自网络"><br>(图片来自网络_出处见右下角水印)<br>公钥为npub开头,私钥为nsec开头,千万不要泄露私钥.    </p><ul><li>公钥（Public Key）可以共享,并对所有人公开,别人通过这个找到你</li><li>私钥（Private Key)需要保密, 可以通过这个密钥来登录账号</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="防止垃圾信息"><a href="#防止垃圾信息" class="headerlink" title="防止垃圾信息"></a>防止垃圾信息</h3><p>现在 Nostr 的公共群组已经成为了垃圾场,全是铺天盖地的中中文广告与诈骗,而针对与此问题的解决方案无非就几种,与处理骚扰短信&#x2F;邮件的手段基本一致  </p><ul><li>用户主动拉黑 低效,用户体验差</li><li>公共黑名单 共同维护定期更新,有点类似于广告屏蔽插件的屏蔽规则</li><li>屏蔽词或算法(AI)过滤, 存在误判漏判的情况,成本也可能会上升</li><li>增加门槛 如:付费发送信息</li></ul><p>不过Iris对此问题进行了一定的解决,相比其它客户端垃圾信息要少许多  </p><blockquote><p>Why is there less spam than on other clients?<br><br>Iris rejects all content from authors that your social network has not interacted with. You get way less spam, but the downside is that discovery of new users is more difficult, and sometimes you don’t see all the messages that appear on other clients.</p></blockquote><h3 id="私钥意外泄露"><a href="#私钥意外泄露" class="headerlink" title="私钥意外泄露"></a>私钥意外泄露</h3><p>如果你的私钥因为意外发送泄露, 你将没有任何挽回措施, 无法常规网站一样进行<code>找回密钥</code>或是<code>两步验证</code><br>摆着你面前的选择或许只有放弃这个账号,创建一个新的账号  </p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul><li>访问缓慢  </li><li>点赞无法撤回  </li><li>如果你的隐私信息在此被公开(盒武器),将没有任何人可以帮助你</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[Nostr]: <a href="https://nostr.com/">https://nostr.com/</a>  </p><p>[Nostr.How&#x2F;]: <a href="https://nostr.how/">https://nostr.how/</a></p><p>[awesome-nostr]: <a href="https://github.com/aljazceru/awesome-nostr">https://github.com/aljazceru/awesome-nostr</a></p><p>[解读 Nostr：抗审查的去中心化社交协议]: <a href="https://web3caff.com/zh/archives/50375">https://web3caff.com/zh/archives/50375</a></p><p>[聊聊 NOSTR 和 审查]: <a href="https://coolshell.cn/articles/22367.html">https://coolshell.cn/articles/22367.html</a></p><p>[分享｜乔良：极简解析 Damus 背后的 Nostr 的工作原理]: <a href="https://mp.weixin.qq.com/s/JeI0XPAVqfLV19mCs8m49Q">https://mp.weixin.qq.com/s/JeI0XPAVqfLV19mCs8m49Q</a></p><p>[Nostr 协议详解（科普篇）]: <a href="https://mp.weixin.qq.com/s/1spfaOmTRGxdxQFVgDjCwQ">https://mp.weixin.qq.com/s/1spfaOmTRGxdxQFVgDjCwQ</a></p>]]></content>
    
    
    <categories>
      
      <category>web3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nostr</tag>
      
      <tag>web3</tag>
      
      <tag>去中心化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高中模拟选课工具_高考选科分班_志愿填报工具_2024大学高校专业选课要求</title>
    <link href="/posts/2023/6de6/"/>
    <url>/posts/2023/6de6/</url>
    
    <content type="html"><![CDATA[<p>高中模拟选课工具_高考选科分班_志愿填报工具_2024大学高校专业选课要求_查看具体数量及百分比_请选物化生喵~  </p><p>数据来自教研院官网-适用于2024年及之后高考的学生<br>本网站特地排除了要求为大专的专业, 因此可能与某些教育机构提供的数据存在差异  </p>    <a scr="https://yuhanawa.github.io/tools/xk/"> 如果没有自动跳转请点击手动跳转>https://yuhanawa.github.io/tools/xk/ </a>    <script> window.location.href = 'https://yuhanawa.github.io/tools/xk/'; </script>    <p>选科<br>物理 化学 生物 政治 历史 地理</p><p>概要<br>可选专业数: 0 + 1286(不限)<br>可选的数: 0 + 17034(不限)<br>专业院校覆盖率 0.0%  </p><p>以下是您可以报考的专业及学校<br>为防止卡顿最大显示320项,详情请使用筛选功能<br>隐藏不限科的专业及大学:   </p><p>输入大学或专业进行筛选:  </p><p>搜索支持模糊搜索(例如:山大&#x3D;&gt;山东大学)</p>]]></content>
    
    
    <categories>
      
      <category>网站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>网站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LALRPOP Tutorial 教程/文档-中文翻译 | LALRPOP Tutorial Chinese Book | LALRPOP是Rust写的解析器生成器</title>
    <link href="/posts/2023/57877/"/>
    <url>/posts/2023/57877/</url>
    
    <content type="html"><![CDATA[<p>🌸 樱花开头的内容为译者添加<br>🌸 翻译自 <a href="http://lalrpop.github.io/lalrpop/tutorial/index.html">LALRPOP 教程 | 学习手册&#x2F;教程&#x2F;文档 | Tutorial</a><br>🌸 导航: <strong><a href="https://yuhanawa.github.io/posts/2023/17808/">&lt;&lt;[上篇-快速开始]</a> - <a href="https://yuhanawa.github.io/posts/2023/11467/">[目录]</a> - <a href="https://yuhanawa.github.io/posts/2023/21239/">[下篇-高级设置]&gt;&gt;</a></strong><br>🌸 原文共9节,译文合为一页,本章目录在右侧</p><md id="00"><h2 id="序言-Index"><a href="#序言-Index" class="headerlink" title="序言 | Index"></a>序言 | Index</h2><p>这是一个关于如何使用 LALRPOP 编写一个简单的计算器的完整的解析器的教程. </p><p>如果你不熟悉什么是解析器生成器(parser generator), 你应该先阅读<a href="https://yuhanawa.github.io/posts/2023/51562/">解析器基础速成 | Crash course on parsers</a>. </p><p>本教程仍然不完整. 如果有时间会再写以下内容:  </p><ul><li>关于解决 shift-reduce 和 reduce-reduce 冲突的建议</li><li>向 Action Code 传递 状态和类型&#x2F;生命周期 参数 (see e.g. <a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/expr_arena.lalrpop">this test</a> invoked <a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/lib.rs">from here</a>).</li><li>使用 <code>@L</code> 和<code> @R</code> 进行位置跟踪 (see e.g. <a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/intern_tok.lalrpop">this test</a>).</li><li>与外部标记器(tokenizers)集成 (see e.g. <a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/expr.lalrpop">this test</a> invoked <a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/lib.rs">from here</a>).</li><li>有条件的宏 (目前还没有好的测试, sorry)</li><li>返回 <code>Result</code> 的代码容易发生的错误 (see e.g. <a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/error.lalrpop">this test</a> invoked <a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/lib.rs">from here</a>).</li><li>转换为使用 <code>LALR(1)</code> 替代 <code>LR(1)</code> (see e.g. <a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/expr_lalr.lalrpop">this test</a> invoked <a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/lib.rs">from here</a>).</li><li>未来一些功能的计划</li></ul><p>🌸 但这篇教程已经13个月没有更新了 (ノ｀Д)ノ</p><md id="01"><h2 id="1-添加-LALRPOP-到-Cargo-toml-Adding-LALRPOP-to-your-Cargo-toml-file"><a href="#1-添加-LALRPOP-到-Cargo-toml-Adding-LALRPOP-to-your-Cargo-toml-file" class="headerlink" title="[1]添加 LALRPOP 到 Cargo.toml|Adding LALRPOP to your Cargo.toml file"></a>[1]添加 LALRPOP 到 <code>Cargo.toml</code>|Adding LALRPOP to your <code>Cargo.toml</code> file</h2><p>🌸 这篇是<del><em>一些废话</em></del> LALRPOP 的一些介绍和大致上<a href="https://yuhanawa.github.io/posts/2023/17808/">快速开始</a>的详细版本<br>🌸 可以快速浏览甚至<a href="#02">跳过到02</a> (记住此时的自信(￣y▽,￣)╭ )</p><p>LALRPOP 作为一个预处理器, 可以与 Cargo 在一起工作. 当 LALRPOP 被调用时, 它会在源代码目录中搜索扩展名为 <code>lalrpop</code> 的文件并创建相应的 <code>rs</code> 文件. 例如, 如果我们有一个 <code>calculator.lalrpop</code> 的文件, 预处理程序会创建一个Rust文件 <code>calculator.rs</code>.<br>顺便说一下, LALRPOP 的语法有意接近于 Rust, 所以应该可以使用Rust的拓展插件来编辑 lalrpop 文件. 只要它不太挑剔(emacs 的 rust-mode 就可以很好地工作). </p><p>首先, 让我们使用 <code>cargo new</code> 来建立一个新的项目. 我们把它叫做<br> <code>calculator</code> (计算器):</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; cargo new --bin calculator</code></pre></div><p>我们现在需要编辑生成的 <a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/Cargo.toml"><code>calculator/Cargo.toml</code></a> 文件来调用 LALRPOP 预处理程序. 生成的文件应该长这样:  </p><div class="code-wrapper"><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[package]name &#x3D; &quot;calculator&quot;version &#x3D; &quot;0.1.0&quot;authors &#x3D; [&quot;Niko Matsakis &lt;niko@alum.mit.edu&gt;&quot;][build-dependencies] # &lt;-- 我们添加了这行和后面的内容! lalrpop &#x3D; &quot;0.19.8&quot;[dependencies]lalrpop-util &#x3D; &quot;0.19.8&quot;regex &#x3D; &quot;1&quot;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-lalrpop" data-language="lalrpop"><code class="language-lalrpop">use std::str::FromStr;grammar;pub Term: i32 &#x3D; &#123;    &lt;n:Num&gt; &#x3D;&gt; n,    &quot;(&quot; &lt;t:Term&gt; &quot;)&quot; &#x3D;&gt; t,&#125;;Num: i32 &#x3D; &lt;s:r&quot;[0-9]+&quot;&gt; &#x3D;&gt; i32::from_str(s).unwrap();</code></pre></div><p>Cargo 可以运行 <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripts</a> 作为预处理步骤. 默认名为 “build.rs”. <code>[build-dependencies]</code> 部分指定了构建脚本的依赖项 – 在本例中, 只有 LALRPOP . </p><p> <code>[dependencies]</code> 部分描述了 LALRPOP 在运行时需要的依赖项. 所有的 LALRPOP 项目必须添加 <code>lalrpop-util</code>  crate. 此外, 如果你不想手动编写词法分析器(lexer), 你需要添加 <code>regex</code> crate 作为依赖. (如果你不知道什么是词法器, 不要担心, 这并不重要. 因为我们将在<a href="#02">下一节-解析数字</a>中介绍它. 如果你<em>知道</em>什么是词法分析器, 并且你想知道如何用手写一个词法分析器并在 LALRPOP 中使用它, 那么请查看<a href="(http://lalrpop.github.io/lalrpop/lexer_tutorial/index.html)">词法分析器教程 | lexer tutorial</a>(链接为原文档, 未翻译)). </p><p>接下来我们要添加 <code>build.rs</code> 文件. 对于那些不熟悉<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">该功能</a>(🌸 指<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripts</a>)的人, <code>build.rs</code> 文件应该放在你的 <code>Cargo.toml</code> 文件旁边, 而不是与你的 Rust 代码放在 <code>src</code> 文件夹下, <code>build.rs</code> 应该是下面的样子: </p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">extern crate lalrpop;fn main() &#123;    lalrpop::process_root().unwrap();&#125;</code></pre></div><p>函数 <code>process_root</code> 会处理你的 <code>src</code> 目录, 将所有 <code>lalrpop</code> 文件转换为 <code>rs</code> 文件. 它非常聪明, 可以检查时间戳, 如果 <code>rs</code> 文件比 <code>lalrpop</code> 文件新, 则不进行任何操作并将生成的 <code>rs</code> 文件标记为只读. 它返回一个 <code>io::Result&lt;()&gt;</code> , 所以 <code>unwrap()</code> 调用只是断言没有发生文件系统错误发生. </p><p><strong>NOTE:</strong> 在Windows上, 必要的API还不稳定, 所以时间戳检查被禁用.<br>🌸 这个NOTE写于数年前, 请以具体情况为准. <del><em>我也不知道具体情况如何,只是善意的提个醒</em></del></p><md id="02"><h2 id="2-解析-括号内的-数字-Parsing-parenthesized-numbers"><a href="#2-解析-括号内的-数字-Parsing-parenthesized-numbers" class="headerlink" title="[2]解析(括号内的)数字|Parsing parenthesized numbers"></a>[2]解析(括号内的)数字|Parsing parenthesized numbers</h2><p>OK, 现在我们已经准备好开始编写一个 LALRPOP 语法了. 在我们处理完整的表达式之前, 让我们从简单的东西开始 – 真的超级简单. 让我们从括号内的整数开始, 比如 <code>123</code> 或 <code>(123)</code> , 甚至是 <code>(((123))</code>. Wow. </p><p>为了处理这个问题, 我们需要添加一个<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator1.lalrpop"><code>calculator1.lalrpop</code></a>, 如下所示. 注意:为了解释起来更容易, 这个是最完整的代码. 下一节将通过采用 LALRPOP 提供的一些简便方法(shorthands)使其更简洁. </p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use std::str::FromStr;grammar;pub Term: i32 &#x3D; &#123;    &lt;n:Num&gt; &#x3D;&gt; n,    &quot;(&quot; &lt;t:Term&gt; &quot;)&quot; &#x3D;&gt; t,&#125;;Num: i32 &#x3D; &lt;s:r&quot;[0-9]+&quot;&gt; &#x3D;&gt; i32::from_str(s).unwrap();</code></pre></div><p>让我们一点一点地看一下. 文件的第一部分是 <code>use</code> 语句和 <code>grammar</code> 语句. 你会在每个 LALRPOP 语法的顶部找到它们. 就像在 Rust 中一样, <code>use</code> 语句只是用来导入文件 事实上, 这些 <code>use</code> 语句只是根据需要复制到生成的 Rust 代码中. </p><p><em>关于下划线和衍生文件的说明:</em> LALRPOP 生成的自己的名字至少有两个前导下划线. 为了避免冲突, 如果它看到你使用的标识符也有两个下划线, 它将添加更多的下划线. 但是如果你使用全局导入以<code>__</code>开头的文件, 你可能会发现存在冲突. 为了避免这种情况, 不要使用全局导入(或者在其他地方定义一些带有两个下划线的名字). </p><p><strong>非终结符声明</strong>在 <code>grammar</code> 声明完后是一堆的<em>非终结符声明</em>. 这个语法有两个非终结符, <code>Term</code> 和 <code>Num</code>. 非终结符只是我们给可以被解析的东西起的一个名字, 然后根据其他内容定义每个非终结符. </p><p>让我们从文件末尾的 <code>Num</code> 开始, 它的声明如下. </p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D;    &lt;s:r&quot;[0-9]+&quot;&gt; &#x3D;&gt; i32::from_str(s).unwrap();</code></pre></div><p>此声明表示 <code>Num</code> 的类型为 <code>i32</code> . 这意味着当我们从输入文本中解析一个 <code>Num</code> 时, 我们将生成一个类型为<code>i32</code>的值. <code>Num</code>的定义是 <code>&lt;s:r&quot;[0-9]+&quot;&gt;</code> . 让我们从内到外看仔细一下. 符号 <code> r&quot;[0-9]+&quot;</code> 是一个正则表达式——这与Rust原始字符串相同. (而且, 跟在Rust中一样, 如果需要嵌入引号, 可以使用 hashes, 例如 <code>r#&quot;...&quot;...&quot;#</code>)它将与符合正则表达式的字符串相匹配: 在本例中是一些数字. 这个匹配的结果是我们正在解析的输入文本中的一个切片(slice) <code>&amp;&#39;input str</code>(引用,不作复制). </p><p>此正则表达式用尖括号括起来并标记为: <code>&lt;s:r&quot;[0-9]+&quot;&gt;</code>. 通常, 在 LALRPOP 中使用尖括号来表示将在<em>动作代码(Action Code)</em>(指解析<code>Num</code>时执行的代码)使用的值, 在本例中, 与正则表达式匹配的字符串绑定到变量<code> s</code>, <code>i32::from_str(s).unwrap()</code> 会解析该字符串创建并返回一个 <code>i32</code>. </p><p>OK, 现在我们来看看非终结符 <code>Term</code>. </p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub Term: i32 &#x3D; &#123;    &lt;n:Num&gt; &#x3D;&gt; n,    &quot;(&quot; &lt;t:Term&gt; &quot;)&quot; &#x3D;&gt; t,&#125;;</code></pre></div><p>首先, 此非终结符声明为 <code>pub</code>. 这意味着 LALRPOP 将生成一个公共结构(正如我们将看到的, 命名为 <code>TermParser</code>), 您可以使用它将字符串解析为 <code>Term</code> . 私有非终结符(如<code>Num</code>)只能在语法本身内部使用, 不能从外部使用. <code>Term</code> 非终结符有两个可供选择的定义, 可以用 <code>&#123; alternative1, alternative2 &#125;</code> 来表示. 在这个例子中, 第一个选项是 <code>&lt;n:Num&gt;</code>, 这表示 <code>Term</code> 可以是一个数字. 所以<code>22</code>是一个 <code>Term</code> . 第二个选择是 <code>&quot;(&quot; &lt;t:Term&gt; &quot;)&quot;</code>, 表示 <code>Term</code> 也可以是带括号的 <code>Term</code>, 所以 <code>(22)</code> 是 <code>Term</code>, <code>((22))</code>, <code>((((((22))))))</code> 等也是<code>Term</code></p><p><strong>调用解析器</strong> OK, 我们编写了解析器, 该如何使用它呢? 对于每个声明为 <code>pub</code> 的非终结符 <code>Foo</code>, LALRPOP 将通过 <code>parse</code> 方法导出 <code>FooParser</code> 结构, 您可以调用该方法将字符串解析为该非终结符. 下面是我们通过添加到<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/main.rs"><code>main.rs</code></a>文件中的一个简单测试来使用此结构来测试我们的 <code>Term</code> 非终结符: </p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[macro_use] extern crate lalrpop_util;lalrpop_mod!(pub calculator1); &#x2F;&#x2F; synthesized by LALRPOP#[test]fn calculator1() &#123;    assert!(calculator1::TermParser::new().parse(&quot;22&quot;).is_ok());    assert!(calculator1::TermParser::new().parse(&quot;(22)&quot;).is_ok());    assert!(calculator1::TermParser::new().parse(&quot;((((22))))&quot;).is_ok());    assert!(calculator1::TermParser::new().parse(&quot;((22)&quot;).is_err());&#125;</code></pre></div><p>parse 方法的完整签名如下所示: </p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">fn parse&lt;&#39;input&gt;(&amp;self, input: &amp;&#39;input str)                     -&gt; Result&lt;i32, ParseError&lt;usize,(usize, &amp;&#39;input str),()&gt;&gt;                     &#x2F;&#x2F;        ~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                     &#x2F;&#x2F;         |                       |                     &#x2F;&#x2F; Result upon success             |                     &#x2F;&#x2F;                                 |                     &#x2F;&#x2F;             Error enum defined in the lalrpop_util crate&#123;    ...&#125;</code></pre></div><md id="03"><h2 id="3-类型推断-Type-inference"><a href="#3-类型推断-Type-inference" class="headerlink" title="[3]类型推断|Type inference"></a>[3]类型推断|Type inference</h2><p>OK, 现在我们理解了<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator1.lalrpop">the calculator1 example</a>, 让我们通过 LALRPOP 提供的一些简便方法来使代码更加简洁, 这段代码可以在<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator2.lalrpop">the calculator2 demo</a>中找到. </p><p>首先, 让我们看看我们之前 <code>Term</code> 的定义:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub Term: i32 &#x3D; &#123;    &lt;n:Num&gt; &#x3D;&gt; n,    &quot;(&quot; &lt;t:Term&gt; &quot;)&quot; &#x3D;&gt; t,&#125;;</code></pre></div><p>这里的动作代码(ActionCode)有点儿意思. 在这两种情况下, 它都没有做任何新的工作, 只是选择一个由另一个非终结符产生的值. 事实上, 这很常见. 所以 LALRPOP 为其提供了一些简便方法, 这是<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator2.lalrpop">the calculator2 demo</a>中 <code>Term</code> 的定义:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub Term &#x3D; &#123; Num, &quot;(&quot; &lt;Term&gt; &quot;)&quot; &#125;;</code></pre></div><p>在这里根本就没有动作代码(ActionCode). 如果没有动作代码, LALRPOP 就会自动生成动作代码, 取被匹配事物的值. 在第一个选项 <code>Num</code> 的情况下, 只有一个匹配项被匹配, 所以这表明无论 <code>Term</code> 的值是什么, 都与我们解析的 <code>Num</code> 的值相同. </p><p>在第二个选项中, <code>&quot;(&quot; &lt;Term&gt; &quot;)&quot;</code>, 有三个字符(串)被匹配. 在这里, 我们用角括号来选择我们要取的值 — 我们只选择了一个值, 所以我们取了我们解析的 <code>Term</code> 的值. 如果我们选择了一个以上的值, 那么结果将是所有选择的值的一个元组. 如果我们没有选择任何值(即 <code>&quot;(&quot; Term &quot;)&quot;</code> ), 结果将是所有值的一个元组, 所以返回类型是 <code>(&amp;&#39;input str, i32, &amp;&#39;input str)</code>.</p><p>说到类型, 你可能已经注意到 <code>Term</code> 没有类型注释. 由于我们没有编写动作代码, 我们可以省略类型注释, 让 LALRPOP 为我们推断. 在此例中, LALRPOP 会推测 <code>Term</code> 与 <code>Num</code> 必须具有相同的类型, 因此类型必须是<code>i32</code>. </p><p>OK, 让我们看看之前在<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator1.lalrpop">calculator1</a>中看到的 <code>Num</code> 的定义. </p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D; &lt;s:r&quot;[0-9]+&quot;&gt; &#x3D;&gt; i32::from_str(s).unwrap();</code></pre></div><p>这个定义也可以做得更短一些. 在<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator2.lalrpop">calculator2</a>,你会发现:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D; r&quot;[0-9]+&quot; &#x3D;&gt; i32::from_str(&lt;&gt;).unwrap();</code></pre></div><p>在这里, 我们没有将<code>s</code>赋值为正则表达式的匹配结果, 而是修改了动作代码(ActionCode), 使用了简短的表达式 <code>&lt;&gt;</code> . 这是一个简便方法, 表示 <ruby>synthesize names for the matched values and insert a comma-separated list here<rt>引号为原文自带 AI翻译:为匹配的值合成名称,并在此插入以逗号分隔的列表</rt></ruby> 在此例中, 只有一个匹配值, <code>r&quot;[0-9]+&quot;</code>, 它返回一个<code>&amp;&#39;input str&#39;</code>, 所以 LALRPOP 将为该值插入一个生成的变量. 注意, 我们仍然有自定义的动作代码, 所有仍然需要类型注释. </p><p>要控制在动作代码中使用<code> &lt;&gt;</code> 表达式时选择的值, 可以使用前面看到的尖括号. 以下是一些示例可供参考, 以便利于用你自己的想法去拓展它们:</p><table><thead><tr><th>Alternative</th><th>Equivalent to</th></tr></thead><tbody><tr><td><code>A =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;a:A&gt; =&gt; bar(a)</code></td></tr><tr><td><code>A B =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;a:A&gt; &lt;b:B&gt; =&gt; bar(a, b)</code></td></tr><tr><td><code>A B =&gt; (&lt;&gt;)</code></td><td><code>&lt;a:A&gt; &lt;b:B&gt; =&gt; (a, b)</code></td></tr><tr><td><code>&lt;A&gt; B =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;a:A&gt; B =&gt; bar(a)</code></td></tr><tr><td><code>&lt;p:A&gt; B =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;p:A&gt; B =&gt; bar(p)</code></td></tr><tr><td><code>&lt;A&gt; &lt;B&gt; =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;a:A&gt; &lt;b:B&gt; =&gt; bar(a, b)</code></td></tr><tr><td><code>&lt;p:A&gt; &lt;q:B&gt; =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;p:A&gt; &lt;q:B&gt; =&gt; bar(p, q)</code></td></tr><tr><td><code>&lt;p:A&gt; B =&gt; Foo &#123;&lt;&gt;&#125;</code></td><td><code>&lt;p:A&gt; B =&gt; Foo &#123;p:p&#125;</code></td></tr><tr><td><code>&lt;p:A&gt; &lt;q:B&gt; =&gt; Foo &#123;&lt;&gt;&#125;</code></td><td><code>&lt;p:A&gt; &lt;q:B&gt; =&gt; Foo &#123;p:p, q:q&#125;</code></td></tr></tbody></table><p>表达式也适用于结构构造函数(如上面例子中的<code>Foo &#123;...&#125;</code>). 如果解析值的名称与结构字段的名称相匹配时效果会很好. </p><md id="04"><h2 id="4-处理完整的表达式-Handling-full-expressions"><a href="#4-处理完整的表达式-Handling-full-expressions" class="headerlink" title="[4]处理完整的表达式|Handling full expressions"></a>[4]处理完整的表达式|Handling full expressions</h2><p>现在我们准备扩展我们的计算器来处理完整的算术表达式(至少涵盖了你小学学习的表达式). 下面是 <a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator3.lalrpop">下一节的计算器示例,calculator3</a>:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use std::str::FromStr;grammar;pub Expr: i32 &#x3D; &#123;    &lt;l:Expr&gt; &quot;+&quot; &lt;r:Factor&gt; &#x3D;&gt; l + r,    &lt;l:Expr&gt; &quot;-&quot; &lt;r:Factor&gt; &#x3D;&gt; l - r,    Factor,&#125;;Factor: i32 &#x3D; &#123;    &lt;l:Factor&gt; &quot;*&quot; &lt;r:Term&gt; &#x3D;&gt; l * r,    &lt;l:Factor&gt; &quot;&#x2F;&quot; &lt;r:Term&gt; &#x3D;&gt; l &#x2F; r,    Term,&#125;;Term: i32 &#x3D; &#123;    Num,    &quot;(&quot; &lt;Expr&gt; &quot;)&quot;,&#125;;Num: i32 &#x3D; &#123;    r&quot;[0-9]+&quot; &#x3D;&gt; i32::from_str(&lt;&gt;).unwrap(),&#125;;</code></pre></div><p>这个示例最有趣的地方在于它如何编码优先级. 优先级的概念当然是在像<code>2+3*4</code>这样的表达式中,我们需要先乘除后加减. 但 LALRPOP 没有内置的功能来给运算符赋予优先级,主要是因为我认为这些功能有些可怕(creepy),不过在语法中通过分层结构来实现优先级还是相当简单的 —— 例如,非终结符<code>Expr</code>涵盖所有的表达式. 它由一系列相互加减的<code>Factor</code>(因子)组成. 一个<code>Factor</code>就是一系列被乘或除的项. 最终,<code>Term</code>是一个单独的数字或一个用括号包裹的完整的表达式. </p><p>从这个例子出发, 编码优先级的典型模式是有每个优先级对于一个非终端符,从最低优先级的运算符 (<code>+</code>, <code>-</code>) 开始,然后加入下一个优先级 (<code>*</code>, <code>/</code>) , 最后加入像 <code>Num</code> 这样的 “atomic(原子)” 表达式. 最后,在atomic表达式中加入括号包裹起来的顶级非终结符(top-level),这样可以让人们重复这段操作来设置下一个优先级(which lets people reset.)</p><p>要知道为什么这样做, 请考虑像 <code>2+3*4</code> 有两种可能的解析树: </p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">2 + 3   *    4          2   +  3   *    4| | |   |    |          |   |  |   |    || | +-Factor-+    OR    +-Expr-+   |    || |     |                   |      |    |+-Expr -+                   +----Factor-+</code></pre></div><p>在第一种中,我们给乘法更高的优先级,在第二个种,我们(错误地)给加法更高的优先级. 如果你现在看一下语法, 你会发现第二种是不可能的: <code>Factor</code> 不能包含 <code>Expr</code> 作为其组成成分. 这就是分层结构的目的:迫使解析器采取你想要的优先级. </p><p>最后,请注意我们只在我们需要解析的的非终结符(<code>Expr</code>)之前写<code>pub</code>,而不是所有. 标记为<code>pub</code>的非终结符会生成额外的代码, 比如可以从其他模块访问解析器调用的<code>new()</code>方法. 如果你<code>pub</code>了不需要<code>pub</code>的非终结符, 你得到一个关于<code>FooParser</code>的未使用<code>new()</code>方法的警告,请从非终结符<code>Foo</code>中删除<code>pub</code>. </p><md id="05"><h2 id="5-构建AST抽象语法树-Building-ASTs"><a href="#5-构建AST抽象语法树-Building-ASTs" class="headerlink" title="[5]构建AST抽象语法树|Building ASTs"></a>[5]构建AST抽象语法树|Building ASTs</h2><p>大多数时候,当你进行解析时,你并不希望计算一个值,你是想构建某种数据结构. 下面是一个简单的例子来说明在 LALRPOP 中是如何做到这一点的. 首先, 我们需要<em>定义</em>我们将要构建的数据结构. 我们将构建一个非常简单的 <code>enum</code>: </p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub enum Expr &#123;    Number(i32),    Op(Box&lt;Expr&gt;, Opcode, Box&lt;Expr&gt;),&#125;pub enum Opcode &#123;    Mul,    Div,    Add,    Sub,&#125;</code></pre></div><p>我们将此代码放入项目中的<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/ast.rs"><code>ast.rs</code>模块</a>中,并为它添加 <code>Debug</code>impl 以便更好地打印输出. 现在我们将创建<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator4.lalrpop">calculator4</a>示例,它将用来构建这个语法树. 首先,让我们只看<code>Expr</code>非终结符,它将向你展示它是如何完成的大部分内容(最有趣的几行已经用注释标出): </p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use std::str::FromStr;use ast::&#123;Expr, Opcode&#125;; &#x2F;&#x2F; (0)grammar;pub Expr: Box&lt;Expr&gt; &#x3D; &#123; &#x2F;&#x2F; (1)    Expr ExprOp Factor &#x3D;&gt; Box::new(Expr::Op(&lt;&gt;)), &#x2F;&#x2F; (2)    Factor,&#125;;ExprOp: Opcode &#x3D; &#123; &#x2F;&#x2F; (3)    &quot;+&quot; &#x3D;&gt; Opcode::Add,    &quot;-&quot; &#x3D;&gt; Opcode::Sub,&#125;;</code></pre></div><p>首先,我们必须通过添加 <code>use</code> 语句将这些新名称导入文件(0). 接下来,我们想生成<code>Box&lt;Expr&gt;</code> 值,所以我们将<code>Expr</code>(以及<code>Factor</code>和<code>Term</code>)的类型更改为<code>Box&lt;Expr&gt;</code>(1). 相应的动作代码在(2)中更改;这里我们使用<code>&lt;&gt;</code>扩展来为<code>Expr::Op</code>提供三个参数. 最后,为了简洁,我们引入了一个<code>ExprOp</code>非终结符(3)来覆盖两个动作代码,现在它们触发相同的动作代码(之前它们触发不同的动作代码). </p><p><code>Factor</code>的定义以类似的方式进行了转换:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Factor: Box&lt;Expr&gt; &#x3D; &#123;    Factor FactorOp Term &#x3D;&gt; Box::new(Expr::Op(&lt;&gt;)),    Term,&#125;;FactorOp: Opcode &#x3D; &#123;    &quot;*&quot; &#x3D;&gt; Opcode::Mul,    &quot;&#x2F;&quot; &#x3D;&gt; Opcode::Div,&#125;;</code></pre></div><p>最后,我们调整<code>Term</code>和<code>Num</code>的定义. 在<code>Num</code>转化到<code>Term</code>时,我们将原始的<code>i32</code>转换为<code>Box &lt; Expr &gt;</code>(4):</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Term: Box&lt;Expr&gt; &#x3D; &#123;    Num &#x3D;&gt; Box::new(Expr::Number(&lt;&gt;)), &#x2F;&#x2F; (4)    &quot;(&quot; &lt;Expr&gt; &quot;)&quot;&#125;;Num: i32 &#x3D; &#123;    r&quot;[0-9]+&quot; &#x3D;&gt; i32::from_str(&lt;&gt;).unwrap()&#125;;</code></pre></div><p>现在我们可以通过向我们的<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/main.rs">main.rs</a>文件添加一些代码来测试它,该代码会解析一个表达式并使用 <code>Debug</code> impl 格式化打印输出:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">lalrpop_mod!(pub calculator4);pub mod ast;#[test]fn calculator4() &#123;    let expr &#x3D; calculator4::ExprParser::new()        .parse(&quot;22 * 44 + 66&quot;)        .unwrap();    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;((22 * 44) + 66)&quot;);&#125;</code></pre></div><md id="06"><h2 id="6-宏-Macros"><a href="#6-宏-Macros" class="headerlink" title="[6]宏|Macros"></a>[6]宏|Macros</h2><p>在写语法时, 我们经常会遇到一些重复的结构,这时我们会进行复制粘贴. 一个常见的例子是定义类似 “逗号分隔的列表” 的东西. 假设我们想解析逗号分隔的表达式列表(当然,还有可选的尾随逗号). 如果我们要完整地写出来,它会看起来像:</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Exprs: Vec&lt;Box&lt;Expr&gt;&gt; &#x3D; &#123;       Exprs &quot;,&quot; Expr &#x3D;&gt; ...,     Expr &#x3D;&gt; vec![], &#125;</code></pre></div><p>当然,这并没有处理尾随逗号,而且我省略了动作代码. 如果我们加上这些, 它会变得更复杂. 到目前为止, 这很好, 但是之后我们还想要逗号分隔的术语列表怎么办?我们只能靠复制粘贴吗?</p><p>LALRPOP 提供了一个更好的选择. 你可以定义宏. 实际上,LALRPOP内置了四个宏: <code>*</code>, <code>?</code>, <code>+</code>, <code>(...)</code>. 例如, 你可以使用<code>Expr?</code>表示 “一个可选的<code>Expr</code>“. 这将使类型变为<code>Option&lt;Box&lt;Expr&gt;&gt;</code>(因为<code>Expr</code>本身的类型就是<code>Box&lt;Expr&gt;</code>). 类似的, 你可以通过写<code>Expr*</code>或<code>Expr+</code>来得到一个<code>Vec&lt;Expr&gt;</code>(最小长度分别为0和1). 最后一个宏是括号, 它是创建一个新的非终端符的简写. 这让你可以写出像<code>(&lt;Expr&gt; &quot;,&quot;)?</code>这样的东西来表示”可选地解析一个后面带有一个逗号的<code>Expr</code>“. 请注意<code>Expr</code>周围的角括号: 这些确保<code>(&lt;Expr&gt; &quot;,&quot;)</code>的值是表达式的值, 而不是表达式和逗号的元组. 这意味着<code>(&lt;Expr&gt; &quot;,&quot;)?</code>的类型是<code>Option&lt;Box&lt;Expr&gt;&gt;</code> (而不是 <code>Option&lt;(Box&lt;Expr&gt;, &amp;&#39;input str)&gt;</code>).</p><p>使用这些操作,我们可以使用宏<code>Comma&lt;T&gt;</code>定义<code>Exprs</code>来创建<code>T</code>的逗号分隔列表,不管<code>T</code>是什么类型(此定义出现在<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator5.lalrpop">calculator5</a>中):</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub Exprs &#x3D; Comma&lt;Expr&gt;; &#x2F;&#x2F; (0)Comma&lt;T&gt;: Vec&lt;T&gt; &#x3D; &#123; &#x2F;&#x2F; (1)    &lt;mut v:(&lt;T&gt; &quot;,&quot;)*&gt; &lt;e:T?&gt; &#x3D;&gt; match e &#123; &#x2F;&#x2F; (2)        None &#x3D;&gt; v,        Some(e) &#x3D;&gt; &#123;            v.push(e);            v        &#125;    &#125;&#125;;</code></pre></div><p>第(0)行的<code>Exprs</code>定义相当明显, 它只使用了 <code>Comma&lt;Expr&gt;</code>宏. 让我们看看第(1)行的<code>Comma&lt;T&gt;</code>的定义. 这有点紧凑, 所以让我们把它先拆开. 首先, <code>T</code>是某个终结符或非终结符. 但请注意我们也可以将其用作类型: 当宏展开时, 类型中的<code>T</code>将被替换成”不管<code>T</code>是什么类型”. </p><p>接下来,在(2)中,我们解析 <code>&lt;mut v:(&lt;T&gt; &quot;,&quot;)*&gt; &lt;e:T?&gt;</code> . </p><p>这里有很多符号, 所以我们先去掉所有的尖括号, 这些角括号只是用来告诉LALRPOP你想传递哪些值, 哪些值要丢弃. 去除一些符号后变成了<code>(T &quot;,&quot;)* T?</code>.<br>希望您可以看出这是匹配一个带有可选尾随逗号的逗号分隔列表. 现在让我们把这些尖括号加回来. 在包裹在小括号中,我们得到 <code>(&lt;T&gt; &quot;,&quot;)*</code> – 这只意味着我们保留<code>T</code>的值, 但在构建我们的向量时丢弃逗号的值. 然后我们捕获该向量并将其称为 <code>v</code>: <code>&lt;mut v:(&lt;T&gt; &quot;,&quot;)*&gt;</code>,<code>mut</code>使<code>v</code>在动作代码中是可变的. 最后, 我们捕获了可选的尾部元素<code>e</code>: <code>&lt;e:T?&gt;</code>. 这意味着Rust代码有两个可用的变量, <code>v: Vec&lt;T&gt;</code> 和 <code>e: Option&lt;T&gt;</code>. 在动作代码本身应该是相当清楚的 – 如果<code>e</code>是<code>Some</code>, 它就把它追加到Vec中并返回结果. </p><p>作为使用宏的另一个例子, 你可能记得我们在<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator4.lalrpop">calculator4</a>中看到的优先级层(<code>Expr</code>, <code>Factor</code>, 等等), 它有一种重复的结构. 你可以用一个宏将其分解. 在这种情况下, 它是一个递归宏: </p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Tier&lt;Op,NextTier&gt;: Box&lt;Expr&gt; &#x3D; &#123;    Tier&lt;Op,NextTier&gt; Op NextTier &#x3D;&gt; Box::new(Expr::Op(&lt;&gt;)),    NextTier&#125;;Expr &#x3D; Tier&lt;ExprOp, Factor&gt;;Factor &#x3D; Tier&lt;FactorOp, Term&gt;;ExprOp: Opcode &#x3D; &#123; &#x2F;&#x2F; (3)    &quot;+&quot; &#x3D;&gt; Opcode::Add,    &quot;-&quot; &#x3D;&gt; Opcode::Sub,&#125;;FactorOp: Opcode &#x3D; &#123;    &quot;*&quot; &#x3D;&gt; Opcode::Mul,    &quot;&#x2F;&quot; &#x3D;&gt; Opcode::Div,&#125;;</code></pre></div><p>当然, 我们需要向 <a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/main.rs">main.rs 文件</a>中添加一些测试:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[macro_use] extern crate lalrpop_util;lalrpop_mod!(pub calculator5);#[test]fn calculator5() &#123;    let expr &#x3D; calculator5::ExprsParser::new().parse(&quot;&quot;).unwrap();    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[]&quot;);    let expr &#x3D; calculator5::ExprsParser::new()        .parse(&quot;22 * 44 + 66&quot;)        .unwrap();    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * 44) + 66)]&quot;);    let expr &#x3D; calculator5::ExprsParser::new()        .parse(&quot;22 * 44 + 66,&quot;)        .unwrap();    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * 44) + 66)]&quot;);    let expr &#x3D; calculator5::ExprsParser::new()        .parse(&quot;22 * 44 + 66, 13*3&quot;)        .unwrap();    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * 44) + 66), (13 * 3)]&quot;);    let expr &#x3D; calculator5::ExprsParser::new()        .parse(&quot;22 * 44 + 66, 13*3,&quot;)        .unwrap();    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * 44) + 66), (13 * 3)]&quot;);&#125;</code></pre></div><md id="07"><h2 id="7-从动作代码中返回错误-Returning-errors-from-actions"><a href="#7-从动作代码中返回错误-Returning-errors-from-actions" class="headerlink" title="[7]从动作代码中返回错误|Returning errors from actions"></a>[7]从动作代码中返回错误|Returning errors from actions</h2><p>有时候,如果动作代码(ActionCode)能够返回错误而不是直接返回<code>T</code>类型的值,这会很实用. 这是因为我们通常不能仅通过语法规则拒绝所有无效输入,工作量太大. </p><p>即使是在我们的计算器示例中,您也可以看到我们正在”欺骗”系统:我们的语法接受无限位数,但它实际上会被解析为<code>i32</code>. 这是一个问题,因为<code>i32</code>可以表示的最大数字是 2147483647. 如果给它一个更大的数字,它会触发Panic,因为它只会考虑到<code>i32</code>转换成功的情况.  </p><p>如果您熟悉Rust的错误处理机制,您可能会认为我们可以让<code>Num</code>返回<code>Option&lt;i32&gt;</code>甚至<code>Result&lt;i32, ...&gt;</code>,您说的对. 但是我们并不需要这样子,因为如果我们可以看看 <code>ExprParser::parse()</code>的返回类型, 它已经返回了<code>Result&lt;i32,ParseError&gt;</code>.所以我们需要的是将其”挂钩”到这个现有的错误机制,并创建可以返回错误的动作代码. </p><p>LALRPOP可以非常容易的通过定义带有 <code>=&gt;?</code> 而不是<code>=&gt;</code>的动作代码来实现这一点. 返回的值然后被假定为<code>Result&lt;T, ParseError&gt;</code>而不是简单的<code>T</code>. </p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D; &#123;    r&quot;[0-9]+&quot; &#x3D;&gt;? i32::from_str(&lt;&gt;)        .map_err(|_| ParseError::User &#123;            error: &quot;number is too big&quot;        &#125;)&#125;;</code></pre></div><p>此外,我们必须在文件的顶部添加<code>use lalrpop_util::ParseError;</code>,以便我们可以访问 <code>ParseError</code>类型. 您可以在<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator6.lalrpop">calculator6.lalrpop</a>中找到完整的代码. 这可以让你很好地处理错误:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[macro_use] extern crate lalrpop_util;lalrpop_mod!(pub calculator6);#[test]fn calculator6() &#123;    &#x2F;&#x2F; Number is one bigger than std::i32::MAX    let expr &#x3D; calculator6::ExprsParser::new().parse(&quot;2147483648&quot;);    assert!(expr.is_err());&#125;</code></pre></div><p>No panics!</p><p>您甚至可以更进一步,定义您自己的错误类型,例如包含所有可能错误的枚举. 这使您可以更轻松地区分不同的错误,而不是依靠字符串. </p><p>为此,假设我们想定义两种错误:</p><ul><li>输入数字太大</li><li>输入号码不是偶数 —— 现在我们将计算器修改为仅接受偶数</li></ul><p>我们首先在 <code>main.rs</code> 中定义我们的错误枚举: </p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[derive(Debug, Copy, Clone, PartialEq, Eq)]pub enum Calculator6Error &#123;    InputTooBig,    OddNumber,&#125;</code></pre></div><p>然后我们将其导入我们的语法,并告诉 LALRPOP 将其用作用户错误类型,所以我们需要将文件的顶部更改为:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use std::str::FromStr;use ast::&#123;Expr, Opcode&#125;;use super::Calculator6Error;use lalrpop_util::ParseError;grammar;extern &#123;    type Error &#x3D; Calculator6Error;&#125;</code></pre></div><p>我们可以通过更改 <code>Num</code> 的定义来使用我们的新错误:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D; &#123;    r&quot;[0-9]+&quot; &#x3D;&gt;? i32::from_str(&lt;&gt;)        .map_err(|_| ParseError::User &#123;            error: Calculator6Error::InputTooBig        &#125;)        .and_then(|i| if i % 2 &#x3D;&#x3D; 0 &#123;            Ok(i)        &#125; else &#123;            Err(ParseError::User &#123;                error: Calculator6Error::OddNumber            &#125;)        &#125;)&#125;;</code></pre></div><p>最后,让我们看看效果如何:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[macro_use] extern crate lalrpop_util;lalrpop_mod!(pub calculator6b);#[test]fn calculator6b() &#123;    use lalrpop_util::ParseError;    let expr &#x3D; calculator6b::ExprsParser::new().parse(&quot;2147483648&quot;);    assert!(expr.is_err());    assert_eq!(expr.unwrap_err(), ParseError::User &#123; error: Calculator6Error::InputTooBig &#125;);    let expr &#x3D; calculator6b::ExprsParser::new().parse(&quot;3&quot;);    assert!(expr.is_err());    assert_eq!(expr.unwrap_err(), ParseError::User &#123; error: Calculator6Error::OddNumber &#125;);&#125;</code></pre></div><p>太酷啦!(There we go!) 你可以在 <a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator6b.lalrpop"><code>calculator6b.lalrpop</code></a> 中找到完整代码.</p><md id="08"><h2 id="8-错误恢复-Error-recovery"><a href="#8-错误恢复-Error-recovery" class="headerlink" title="[8]错误恢复|Error recovery"></a>[8]错误恢复|Error recovery</h2><p>默认情况下,解析器遇到错误时会立即停止. 但有时我们想要尝试恢复并继续. LALRPOP 可以做到这一点,但您必须通过在语法中定义各种”错误恢复”点来帮助它. 这是通过使用特殊的<code>!</code> 符号(token)完成的:这个符号只在解析器遇到输入中的错误时出现. 当出现错误时,解析器会尝试恢复并继续; 它通过将<code>!</code>符号进入stream中,执行它可以执行的任何操作,然后丢弃输入的tokens,直到找到可以让它继续的东西. </p><p>让我们看看如何使用错误恢复来恢复在解析时遇到的多个错误. 首先,我们需要一种方式来返回多个错误,因为这不是 LALRPOP 自身做的事情,所以我们添加一个存储在解析时遇到的错误的<code>Vec</code>. 由于<code>!</code>的结果包含一个token,但错误恢复要求token可以被克隆(cloned). 我们需要用这个替换LALRPOP文件中的 “grammar” 行: </p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">grammar&lt;&#39;err&gt;(errors: &amp;&#39;err mut Vec&lt;ErrorRecovery&lt;usize, Token&lt;&#39;input&gt;, &amp;&#39;static str&gt;&gt;);</code></pre></div><p>Since an alternative containing <code>!</code> is expected to return the same type of<br>value as the other alternatives in the production we add an extra variant to<br><code>Expr</code> to indicate that an error was found.</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub enum Expr &#123;    Number(i32),    Op(Box&lt;Expr&gt;, Opcode, Box&lt;Expr&gt;),    Error,&#125;</code></pre></div><p>最后,我们修改语法,添加包含<code>!</code>的第三个替代方案(alternative),它简单地将从<code>!</code>接收的<code>ErrorRecovery</code>值存储在<code>errors</code>中,并返回<code>Expr::Error</code>. 错误token的值将是一个<a href="https://docs.rs/lalrpop-util/0.12.1/lalrpop_util/enum.ParseError.html"><code>ParseError</code>值</a>. </p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Term: Box&lt;Expr&gt; &#x3D; &#123;    Num &#x3D;&gt; Box::new(Expr::Number(&lt;&gt;)),    &quot;(&quot; &lt;Expr&gt; &quot;)&quot;,    ! &#x3D;&gt; &#123; errors.push(&lt;&gt;); Box::new(Expr::Error) &#125;,&#125;;</code></pre></div><p>现在我们可以添加包含各种错误(例如,缺少操作对象)的测试. 注意,现在<code>parse</code>方法有两个参数而不是一个,这是因为我们重写了 LALRPOP 文件中的 “grammer” 行. 您可以看到解析器通过在必要的地方插入<code>!</code>token来从缺少操作对象中恢复. </p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[test]fn calculator7() &#123;    let mut errors &#x3D; Vec::new();    let expr &#x3D; calculator7::ExprsParser::new()        .parse(&amp;mut errors, &quot;22 * + 3&quot;)        .unwrap();    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * error) + 3)]&quot;);    let expr &#x3D; calculator7::ExprsParser::new()        .parse(&amp;mut errors, &quot;22 * 44 + 66, *3&quot;)        .unwrap();    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * 44) + 66), (error * 3)]&quot;);    let expr &#x3D; calculator7::ExprsParser::new()        .parse(&amp;mut errors, &quot;*&quot;)        .unwrap();    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[(error * error)]&quot;);    assert_eq!(errors.len(), 4);&#125;</code></pre></div><md id="09"><h2 id="9-传递状态参数-Passing-state-parameter"><a href="#9-传递状态参数-Passing-state-parameter" class="headerlink" title="[9]传递状态参数|Passing state parameter"></a>[9]传递状态参数|Passing state parameter</h2><p>默认情况下, 分析器不接受除输入以外的任何参数. 在构建AST时, 可能存在需要向分析器传递参数的特殊需求.</p><p>回到<code>calculator4</code>的例子中, 我们可以向解析器传递一个参数: </p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">grammar(scale: i32);</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D; &#123;    r&quot;[0-9]+&quot; &#x3D;&gt; i32::from_str(&lt;&gt;).unwrap()*scale,&#125;;</code></pre></div><p>这里解析器将接受一个<code>scale</code>参数, 该参数将对遇到的每个数字进行缩放. </p><p>然后我们可以调用解析器传递<code>scale</code>参数 :</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[test]fn calculator8() &#123;    let scale &#x3D; 2;    let expr &#x3D; calculator8::ExprParser::new()        .parse(scale,&quot;11 * 22 + 33&quot;)        .unwrap();    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;((22 * 44) + 66)&quot;);&#125;</code></pre></div><p>对于使用<a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/expr_arena_ast.rs">此结构</a>来构建AST的更实用的示例,请查看<a href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/expr_arena.lalrpop">此解析器</a>. </p></md></md></md></md></md></md></md></md></md></md>]]></content>
    
    
    <categories>
      
      <category>LALRPOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LALRPOP</tag>
      
      <tag>Rust</tag>
      
      <tag>翻译</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LALRPOP 高级设置 文档/教程-中文翻译 | LALRPOP Advanced setup</title>
    <link href="/posts/2023/21239/"/>
    <url>/posts/2023/21239/</url>
    
    <content type="html"><![CDATA[<p>🌸 樱花开头的内容为译者添加<br>🌸 翻译自 <a href="http://lalrpop.github.io/lalrpop/advanced_setup.html">LALRPOP 教程 | 高级设置 | Advanced setup</a><br>🌸 导航: <strong><a href="https://yuhanawa.github.io/posts/2023/17808/">&lt;&lt;[上篇-正式教程]</a> - <a href="https://yuhanawa.github.io/posts/2023/11467/">[目录]</a> - <a href="https://yuhanawa.github.io/posts/2023/11467/">[下篇-这是最后一篇]&gt;&gt;</a></strong><br>🌸 <a href="https://yuhanawa.github.io/posts/2023/57877/">完整的中文文档(共9篇19k字):</a> <a href="https://yuhanawa.github.io/posts/2023/57877">https://yuhanawa.github.io/posts/2023/57877</a></p><h2 id="高级设置-Advanced-setup"><a href="#高级设置-Advanced-setup" class="headerlink" title="高级设置|Advanced setup"></a>高级设置|Advanced setup</h2><p>当你设置 LALRPOP 时, 你创建了一个 <code>build.rs</code> 文件, 看起来像这样:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">extern crate lalrpop;fn main() &#123;    lalrpop::process_root().unwrap();&#125;</code></pre></div><p>这个 <code>process_root()</code> 调用只是使用了默认的配置. 所以它会在*当前路径(in-place)*（在你的<code>src</code>目录下）下把<code>.lalrpop</code>文件转化为<code>.rs</code>文件. 而且只有在 <code>.lalrpop</code> 文件发生改变时才会进行. 但是你也可以使用<a href="https://docs.rs/lalrpop/*/lalrpop/struct.Configuration.html"><code>Configuration</code></a> 结构来获得更精确(detailed)的控制. </p><p>比如, 想要<strong>强制</strong>在输出中使用颜色（忽略TTY设置）, 你这样修改你的<code>build.rs</code>. </p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">extern crate lalrpop;fn main() &#123;    lalrpop::Configuration::new()        .always_use_colors()  &#x2F;&#x2F; 🌸 添加这行        .process_current_dir();&#125;</code></pre></div><md id="generate_in_source">  <h3 id="在源代码树中生成-Generate-in-source-tree"><a href="#在源代码树中生成-Generate-in-source-tree" class="headerlink" title="在源代码树中生成|Generate in source tree"></a>在源代码树中生成|Generate in source tree</h3><p>🌸 <a href="http://lalrpop.github.io/lalrpop/generate_in_source.html">原文</a>为单独一页 现在将其整合为一页</p><p>在0.15版本以前, LALRPOP 是在输入文件的同一目录下生成文件. 从0.16开始, 文件生成在Cargo的<strong>输出目录</strong>. </p><p>如果你想保持以前的习惯, 你可以调用<code>generate_in_source_tree</code>.<br>在你的配置中:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">extern crate lalrpop;fn main() &#123;    lalrpop::Configuration::new()        .generate_in_source_tree() &#x2F;&#x2F;🌸 添加这行        .process();&#125;</code></pre></div><p>对于每一个 <code>foo.lalrpop</code> 文件, 你可以简单地在你的源代码树中设置<code>mod foo;</code>. <code>lalrpop_mod</code>宏在这种模式下不是很有用. </p></md>]]></content>
    
    
    <categories>
      
      <category>LALRPOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LALRPOP</tag>
      
      <tag>Rust</tag>
      
      <tag>翻译</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LALRPOP 快速开始 文档/教程-中文翻译 | LALRPOP Quick start guide</title>
    <link href="/posts/2023/17808/"/>
    <url>/posts/2023/17808/</url>
    
    <content type="html"><![CDATA[<p>🌸 樱花开头的内容为译者添加<br>🌸 翻译自 <a href="http://lalrpop.github.io/lalrpop/quick_start_guide.html">LALRPOP 教程 | 快速开始 | Quick start guide</a><br>🌸 导航: <strong><a href="https://yuhanawa.github.io/posts/2023/51562/">&lt;&lt;[上篇-基础速成]</a> - <a href="https://yuhanawa.github.io/posts/2023/11467/">[目录]</a> - <a href="https://yuhanawa.github.io/posts/2023/57877/">[下篇-正式教程]&gt;&gt;</a></strong><br>🌸 <a href="https://yuhanawa.github.io/posts/2023/57877/">完整的中文文档(共9篇19k字):</a> <a href="https://yuhanawa.github.io/posts/2023/57877">https://yuhanawa.github.io/posts/2023/57877</a></p><h2 id="快速开始-Quick-start"><a href="#快速开始-Quick-start" class="headerlink" title="快速开始 | Quick start"></a>快速开始 | Quick start</h2><p>要开始使用 LALRPOP, 最好是阅读<a href="https://yuhanawa.github.io/posts/2023/57877/">教程</a>, 它将向你介绍 LALRPOP 文件的语法, 等等.<br>但是如果你以前做过这个, 或者你是那种<em>没有耐心</em>的人.这里有一个快速的 “小抄”, 用于设置你的项目. 首先, 添加以下几行到你的 <code>Cargo.toml</code>:</p><div class="code-wrapper"><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[package]...build &#x3D; &quot;build.rs&quot; # LALRPOP preprocessing# 生成的代码依赖于 lalrpop-util.# # 生成的标志器依赖于 regex crate.# # (如果你写了自己的标记器,或者已经有了 regex crate，你可以跳过这个依赖)[dependencies]lalrpop-util &#x3D; &quot;0.19.8&quot;regex &#x3D; &quot;1&quot;# 添加构建时的 lalrpop 依赖:[build-dependencies]lalrpop &#x3D; &quot;0.19.8&quot;# 如果你提供你自己的外部 lexer，你可以通过禁用 default-features 来使其不包括内置 lexer 功能。# lalrpop &#x3D; &#123; version &#x3D; &quot;0.19.1&quot;, default-features &#x3D; false &#125;</code></pre></div><p>接下来创建一个 <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a> 文件, 看起来像这样:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">extern crate lalrpop;fn main() &#123;    lalrpop::process_root().unwrap();&#125;</code></pre></div><p>(如果你已经有一个<code>build.rs</code>文件了, 无论该文件在做什么, 你可以直接调用<code>process_root</code>)</p><p>这就行了, 注意<code>process_root</code>只是使用默认设置.<br>如果你想配置 LALRPOP 的执行方式, 请看 <a href="/posts/2023/21239/">高级设置|Advanced setup</a>.  </p><h3 id="手动运行"><a href="#手动运行" class="headerlink" title="手动运行"></a>手动运行</h3><p>如果你愿意, 你也可以将 <code>lalrpop</code> crate作为一个可执行文件.只需运行<code>cargo install lalrpop</code>, 然后你就会得到一个可执行的二进制文件, 像这样:</p><div class="code-wrapper"><pre class="line-numbers language-APPLESCRIPT" data-language="APPLESCRIPT"><code class="language-APPLESCRIPT">lalrpop file.lalrpop</code></pre></div><p>这将为你生成<code>file.rs</code>.注意, 它只在<code>file.lalrpop</code>比<code>file.rs</code>新的情况下执行<br>如果你想无条件地执行, 请传递参数<code>-f</code>（也可以尝试<code>--help</code>以获得其他选项）.</p>]]></content>
    
    
    <categories>
      
      <category>LALRPOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LALRPOP</tag>
      
      <tag>Rust</tag>
      
      <tag>翻译</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LALRPOP 解析器基础速成 文档/教程-中文翻译 | LALRPOP Crash course on parsers</title>
    <link href="/posts/2023/51562/"/>
    <url>/posts/2023/51562/</url>
    
    <content type="html"><![CDATA[<p>🌸 樱花开头的内容为译者添加<br>🌸 翻译自 <a href="http://lalrpop.github.io/lalrpop/crash_course.html">LALRPOP 教程 | 解析器基础速 | Crash course on parsers</a>, 这篇为基础速成, 如有基础可跳过, 正式内容在下一篇<br>🌸 导航: <strong><a href="https://yuhanawa.github.io/posts/2023/11467/#LALRPOP">&lt;&lt;[上篇-介绍]</a> - <a href="https://yuhanawa.github.io/posts/2023/11467/">[目录]</a> - <a href="https://yuhanawa.github.io/posts/2023/17808/">[下篇-快速开始]&gt;&gt;</a></strong><br>🌸 <a href="https://yuhanawa.github.io/posts/2023/57877/">完整的中文文档(共9篇19k字):</a> <a href="https://yuhanawa.github.io/posts/2023/57877">https://yuhanawa.github.io/posts/2023/57877</a><br>🌸 在下文中 grammar 译作 语法； Term不译</p><h2 id="解析器基础速成-Crash-course-on-parsers"><a href="#解析器基础速成-Crash-course-on-parsers" class="headerlink" title="解析器基础速成 | Crash course on parsers"></a>解析器基础速成 | Crash course on parsers</h2><p>如果你以前从未使用过解析器生成器(parser generator), 或者对上下文无关文法(context-free grammars)并不熟悉,这节只是<strong>非常简要地</strong>介绍一下这个基本概念. 语法(grammar)是一种很好的方式, 可以写出哪些类型的输入是合法的.<br>在我们的例子中, 我们想支持括号内的数字, 像<code>123</code>, <code>(123)</code>等.我们可以用一个简单的语法来表达这一点, 比如:</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Term &#x3D; Num | &quot;(&quot; Term &quot;)&quot;</code></pre></div><p>在这里, 我们说我们试图解析一个<strong>Term(术语)</strong>, 一个Term可以是一个数字(<code>Num</code>)或其他括号内的Term(这里我们没有定义什么是数字, 但在真正的 LALRPOP 例子中, 我们将用正则表达式来定义). 现在想象一个潜在的输入如<code>((123))</code>. 我们可以通过写出一个叫做 “解析树(parse tree)” 的东西来说明如何解析这个数字:</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">(  (  1  2  3  )  )|  |  |     |  |  ||  |  +-Num-+  |  ||  |     |     |  ||  |   Term    |  ||  |     |     |  ||  +---Term----+  ||        |        |+------Term-------+</code></pre></div><p>这里你可以看到, 我们解析<code>((123))</code>的方法是在中间找到一个<code>Num</code>, 把这个<code>Num</code>称为<code>Term</code>, 然后匹配小括号, 在这个基础上形成另外两个Term.  </p><p>注意, 这个解析树不是一个数据结构, 而是解析的可视化. 我的意思是, 你<em>可以</em>建立一个解析树作为一个数据结构, 但通常你不会这样做: 因为你不需要这么详细.比如, 你可能对从 <code>Num</code> 到 <code>Term</code> 的无操作转换并不感兴趣. 关于解析树的另一个讨厌(weird)之处在于它与你的语法密切相关, 但往往你需要解析一些现有的数据结构 – 所以如果你建立了一个解析树, 那么你就必须将解析树转换为这些数据结构, 这可能是烦人的.  </p><p>🌸 (非)终结符 可以暂时通俗理解为 (不)可继续进行推到的字符<br>因此, 解析器生成器通常做的是让你选择如何表示解析树中的每个节点, 以及如何进行转换. 你给每个非终结符(nonterminal)一个类型, 它可以是任何Rust中的类型, 你写的代码将在每次解析树中的新节点被构建时执行. 实际上, 在后面的例子中, 我们最终会建立类似于解析树的东西, 但在开始时, 我们根本不会这样做. 相反, 我们将把每个数字和 term 表示为一个 <code>i32</code> , 并且我们将在节点周围传播这个值.   </p><p>为了使之更具体, 这里有一个用 LALRPOP 编写的上述语法(🌸<code>Term=Num|&quot;(&quot; Term &quot;)&quot;</code>)的版本(在后面详细的教程中会再次讲解). 你可以看到 <code>Term</code> 非终结符被赋予了 <code>i32</code> 类型, 每个定义都有一些代码跟在 <code>=&gt;</code> 符号后面.这些是将要执行的代码, 该代码会将匹配的内容(如数字或括号内的)Term转换为 <code>i32</code>:</p><div class="code-wrapper"><pre class="line-numbers language-lalrpop" data-language="lalrpop"><code class="language-lalrpop">Term: i32 &#x3D; &#123;    Num &#x3D;&gt; &#x2F;* ... number code ... *&#x2F;,    &quot;(&quot; Term &quot;)&quot; &#x3D;&gt; &#x2F;* ... parenthesized code ... *&#x2F;,&#125;;</code></pre></div><p>OK, 基础知识到此为止足够了, 让我们正式的开始吧!  </p>]]></content>
    
    
    <categories>
      
      <category>LALRPOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LALRPOP</tag>
      
      <tag>Rust</tag>
      
      <tag>翻译</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LALRPOP 目录&amp;介绍 文档/教程-中文翻译 | LALRPOP Readme Summary</title>
    <link href="/posts/2023/11467/"/>
    <url>/posts/2023/11467/</url>
    
    <content type="html"><![CDATA[<p>🌸 樱花开头的内容为译者添加<br>🌸 翻译自 <a href="http://lalrpop.github.io/lalrpop/index.html">LALRPOP 教程 | 目录&amp;介绍 | Readme Summary</a><br>🌸 这篇是介绍&amp;目录部分,  目录为双语目录,  链接为译文链接<br>🌸 <a href="https://yuhanawa.github.io/posts/2023/57877/">完整的中文文档(共9篇19k字):</a> <a href="https://yuhanawa.github.io/posts/2023/57877">https://yuhanawa.github.io/posts/2023/57877</a><br>🌸 施工中… 英文目录为未翻译</p><h2 id="目录-Summary"><a href="#目录-Summary" class="headerlink" title="目录 Summary"></a>目录 Summary</h2><ul><li><a href="https://yuhanawa.github.io/posts/2023/11467/">LALRPOP介绍&amp;目录(本文)</a></li><li><a href="https://yuhanawa.github.io/posts/2023/51562/">解析器基础速成|Crash course on parsers</a></li><li><a href="https://yuhanawa.github.io/posts/2023/17808/">快速开始|Quick start guide</a></li><li><a href="https://yuhanawa.github.io/posts/2023/57877/">手册|Tutorial</a><ul><li><a href="https://yuhanawa.github.io/posts/2023/57877/#01">添加 LALRPOP 到你的项目|Adding LALRPOP to your project</a></li><li><a href="https://yuhanawa.github.io/posts/2023/57877/#02">解析(括号内的)数字|Parsing parenthesized numbers</a></li><li><a href="https://yuhanawa.github.io/posts/2023/57877/#03">类型推断|Type inference</a></li><li><a href="https://yuhanawa.github.io/posts/2023/57877/#04">处理完整的表达式|Handling full expressions</a></li><li><a href="https://yuhanawa.github.io/posts/2023/57877/#05">构建AST抽象语法树|Building ASTs</a></li><li><a href="https://yuhanawa.github.io/posts/2023/57877/#06">宏|Macros</a></li><li><a href="https://yuhanawa.github.io/posts/2023/57877/#07">从动作代码中返回错误|Fallible actions</a></li><li><a href="https://yuhanawa.github.io/posts/2023/57877/#08">错误恢复|Error recovery</a></li><li><a href="https://yuhanawa.github.io/posts/2023/57877/#09">传递状态参数|Passing state parameter</a></li></ul></li><li><a href="http://lalrpop.github.io/lalrpop/lexer_tutorial/index.html">未翻译|Controlling the lexer</a><ul><li><a href="http://lalrpop.github.io/lalrpop/lexer_tutorial/index.html">未翻译|LALRPOP’s lexer generator</a></li><li><a href="http://lalrpop.github.io/lalrpop/lexer_tutorial/index.html">未翻译|Writing a custom lexer</a></li><li><a href="http://lalrpop.github.io/lalrpop/lexer_tutorial/index.html">未翻译|Using tokens with references</a></li></ul></li><li><a href="https://yuhanawa.github.io/posts/2023/21239/">高级设置|Advanced setup</a><ul><li><a href="https://yuhanawa.github.io/posts/2023/21239/#generate_in_source">在源代码树中生成|Generate in source tree</a></li></ul></li></ul><hr><h2 id="LALRPOP"><a href="#LALRPOP" class="headerlink" title="LALRPOP"></a>LALRPOP</h2><p>LALRPOP 是一个解析器生成器(parser generator), 原理上类似于 <a href="http://dinosaur.compilertools.net/yacc/">YACC</a> (🌸404 Not Found),  <a href="http://www.antlr.org/">ANTLR</a>,  <a href="http://gallium.inria.fr/~fpottier/menhir/">Menhir</a> , 以及其他此类程序.<br>总的来说, 它的宏伟目标是成为有史以来最有用的解析器生成器. 这个目标肯定没有完全实现：现在, 它是比较普通(fairly standard)的, 甚至在某些方面有点不合格. 但是, 它还很年轻.   </p><p>这份文件大部分内容在描述 LALRPOP 当前的状况,  部分内容包括了对未来计划中的变化的说明.   </p><h2 id="🌸-介绍-AI生成"><a href="#🌸-介绍-AI生成" class="headerlink" title="🌸 介绍(AI生成)"></a>🌸 介绍(AI生成)</h2><h3 id="LALRPOP-是一个用于-Rust-语言的-LR-1-解析器生成器。它可以从用户定义的语法规则生成一个解析器。"><a href="#LALRPOP-是一个用于-Rust-语言的-LR-1-解析器生成器。它可以从用户定义的语法规则生成一个解析器。" class="headerlink" title="LALRPOP 是一个用于 Rust 语言的 LR(1) 解析器生成器。它可以从用户定义的语法规则生成一个解析器。"></a>LALRPOP 是一个用于 Rust 语言的 LR(1) 解析器生成器。它可以从用户定义的语法规则生成一个解析器。</h3><p>LALRPOP 的主要功能有:</p><ol><li>从用户定义的上下文无关文法(CFG)生成 LR(1) 解析表和 GOTO 表,构造一个 LR(1) 解析器。</li><li>支持自动 error recovery,可以在解析错误时自动进行错误恢复。</li><li>生成的解析器以 Rust 代码形式输出,方便与 Rust 项目集成。</li><li>支持参数化规则,可以定义泛型解析器。</li><li>支持空 Productions,以实现可选符号。</li><li>可视化的解析过程,可以更直观地理解表驱动解析。<br>使用 LALRPOP 的典型步骤是:</li><li>定义语法规则:使用类 EBNF 记法定义上下文无关文法。</li><li>运行 LALRPOP:使用 cargo-lalrpop 运行 LALRPOP 生成 Rust 代码。</li><li>使用解析器:在项目中引入解析器代码,调用解析器解析输入字符串。</li><li>处理语义动作:在解析过程中,使用自定义代码处理语义动作。<br>LALRPOP 是实现编译器等语言处理工具的有力工具,通过它可以更简单地构造一个强大的解析器。<br>总之,LALRPOP 是一个非常实用的工具,值得学习和使用。</li></ol><hr><md id="conditional-compilation"><h2 id="conditional-compilation-md"><a href="#conditional-compilation-md" class="headerlink" title="conditional-compilation.md"></a>conditional-compilation.md</h2><p>🌸 该内容独暂一页, 但没有任何链接指向该页面, 推测该内容还在编写中, 但已经4年没有更新了, 所以暂时将此内容放置在此</p><p>LALRPOP 支持通过 <code>#[cfg(feature = &quot;FEATUERE&quot;)]</code> 属性对 公共非终结符声明 进行条件性编译.<br>如果在构建脚本中运行, LALRPOP 将自动从 <code>cargo</code> 中获取特性并使用这些特性.<br>另外, 也可以使用 <code>Configuration</code> 类型来设置明确的特征集(features set). </p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[cfg(feature &#x3D; &quot;FEATURE&quot;)]pub MyRule : () &#x3D; &#123;    ...&#125;;</code></pre></div></md>]]></content>
    
    
    <categories>
      
      <category>LALRPOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LALRPOP</tag>
      
      <tag>Rust</tag>
      
      <tag>翻译</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>砖家建议不要建议&amp;专家都说了些什么</title>
    <link href="/posts/2023/28310/"/>
    <url>/posts/2023/28310/</url>
    
    <content type="html"><![CDATA[<h2 id="砖家–何不食肉糜"><a href="#砖家–何不食肉糜" class="headerlink" title="砖家–何不食肉糜"></a>砖家–何不食肉糜</h2><p><img src="/posts/2023/28310/%E5%9C%A3%E4%BA%BA.png" alt="圣人"></p><h3 id="经济学教授-林采宜-老百姓有钱，油价上涨无所谓"><a href="#经济学教授-林采宜-老百姓有钱，油价上涨无所谓" class="headerlink" title="[经济学教授-林采宜] 老百姓有钱，油价上涨无所谓"></a>[经济学教授-林采宜] 老百姓有钱，油价上涨无所谓</h3><h3 id="博士生导师-翟翌-，发表了一篇名为《以养老金为抓手，推动中国老人接种疫苗》"><a href="#博士生导师-翟翌-，发表了一篇名为《以养老金为抓手，推动中国老人接种疫苗》" class="headerlink" title="[博士生导师-翟翌]，发表了一篇名为《以养老金为抓手，推动中国老人接种疫苗》"></a>[博士生导师-翟翌]，发表了一篇名为《以养老金为抓手，推动中国老人接种疫苗》</h3><h3 id="浙江财院教授-谢作诗-收入低的男人，可以几个人合起来找一个老婆"><a href="#浙江财院教授-谢作诗-收入低的男人，可以几个人合起来找一个老婆" class="headerlink" title="[浙江财院教授-谢作诗] 收入低的男人，可以几个人合起来找一个老婆"></a>[浙江财院教授-谢作诗] 收入低的男人，可以几个人合起来找一个老婆</h3><h3 id="昆明市政协委员-胡开林-历史说明中国贫富差距越大越好"><a href="#昆明市政协委员-胡开林-历史说明中国贫富差距越大越好" class="headerlink" title="[昆明市政协委员-胡开林] 历史说明中国贫富差距越大越好"></a>[昆明市政协委员-胡开林] 历史说明中国贫富差距越大越好</h3><h3 id="厦门大学教授-赵燕菁-适当处罚不生孩子的年轻人"><a href="#厦门大学教授-赵燕菁-适当处罚不生孩子的年轻人" class="headerlink" title="[厦门大学教授-赵燕菁]适当处罚不生孩子的年轻人"></a>[厦门大学教授-赵燕菁]适当处罚不生孩子的年轻人</h3><h3 id="全国工商联常委-丁佐宏-66岁到79岁仍是中年，要鼓励60岁以上初老群体再就业"><a href="#全国工商联常委-丁佐宏-66岁到79岁仍是中年，要鼓励60岁以上初老群体再就业" class="headerlink" title="[全国工商联常委-丁佐宏]66岁到79岁仍是中年，要鼓励60岁以上初老群体再就业"></a>[全国工商联常委-丁佐宏]66岁到79岁仍是中年，要鼓励60岁以上初老群体再就业</h3><h3 id="社会数据研究中心主任-许宪春-低收入人群可以出租闲置房或者用私家车拉活增加收入"><a href="#社会数据研究中心主任-许宪春-低收入人群可以出租闲置房或者用私家车拉活增加收入" class="headerlink" title="[社会数据研究中心主任-许宪春] 低收入人群可以出租闲置房或者用私家车拉活增加收入"></a>[社会数据研究中心主任-许宪春] 低收入人群可以出租闲置房或者用私家车拉活增加收入</h3><h3 id="经济学家-陈浩-国内家庭平均总资产300万正常，现在谁家还没有个50万的现金呢"><a href="#经济学家-陈浩-国内家庭平均总资产300万正常，现在谁家还没有个50万的现金呢" class="headerlink" title="[经济学家-陈浩] 国内家庭平均总资产300万正常，现在谁家还没有个50万的现金呢"></a>[经济学家-陈浩] 国内家庭平均总资产300万正常，现在谁家还没有个50万的现金呢</h3><h3 id="人口经济学家-梁建章-年轻人如果暂时找不到工作，可以先去结婚生子"><a href="#人口经济学家-梁建章-年轻人如果暂时找不到工作，可以先去结婚生子" class="headerlink" title="[人口经济学家-梁建章] 年轻人如果暂时找不到工作，可以先去结婚生子"></a>[人口经济学家-梁建章] 年轻人如果暂时找不到工作，可以先去结婚生子</h3><h3 id="全国人大代表、小康集团董事长-张兴海-建议年轻人多进厂打工，鼓励支持年轻人争当产业工人，这样才有助于制造业的发展，不能只考虑个人收入"><a href="#全国人大代表、小康集团董事长-张兴海-建议年轻人多进厂打工，鼓励支持年轻人争当产业工人，这样才有助于制造业的发展，不能只考虑个人收入" class="headerlink" title="[全国人大代表、小康集团董事长-张兴海] 建议年轻人多进厂打工，鼓励支持年轻人争当产业工人，这样才有助于制造业的发展，不能只考虑个人收入"></a>[全国人大代表、小康集团董事长-张兴海] 建议年轻人多进厂打工，鼓励支持年轻人争当产业工人，这样才有助于制造业的发展，不能只考虑个人收入</h3><p>注意: 多人重名 注意辨别<br>张兴海：男，1963年8月出生，中国国籍，高级管理人员工商管理硕士，经济师，中国汽车人才研究会理事会副理事长，重庆汽车工程学会副理事长。<br>曾荣获全国非公有制经济人士优秀中国特色社会主义事业建设者、中国光彩事业奖章、重庆市第四届劳动模范、全国“关爱员工优秀民营企业家”、全国抗震救灾先进个人、振兴重庆争光贡献奖、重庆市首届十大慈善人物等。<br>曾任巴县凤凰电器弹簧厂厂长，重庆渝安创新科技（集团）有限公司董事长，重庆小康汽车集团有限公司董事长、总裁，东风小康汽车有限公司总经理。<br>现任公司董事长兼总裁。</p><h2 id="争议–反讽或洗白"><a href="#争议–反讽或洗白" class="headerlink" title="争议–反讽或洗白?"></a>争议–反讽或洗白?</h2><h3 id="反讽-经济学家-许石林-：强烈建议恢复民跪官制"><a href="#反讽-经济学家-许石林-：强烈建议恢复民跪官制" class="headerlink" title="[*反讽-经济学家-许石林]：强烈建议恢复民跪官制"></a>[*反讽-经济学家-许石林]：强烈建议恢复民跪官制</h3><p>总结:  许石林并非经济学家，而是杂文作家，主要成就有 首届中国鲁迅杂文奖 广东省鲁迅文艺奖 广东省有为文学奖.<br>文章摘要:<br>其实我愿意见官下跪，以便让官更像官，让官有官威、官仪、官气，所谓君君臣臣、官官民民、上上下下嘛。官们内心无不希望小民下跪才行……于是，官没责任了。不把官们称父母官，官就不爱民如子了，也不做民之楷模了。所以，强烈建议恢复民跪官制。<br>作者详情:<br>国家一级作家、中国作家协会会员，深圳市文艺评论家协会副主席、深圳市杂文学会会长、深圳市非物质文化遗产保护专家、中华吟诵学会理事、中国古琴学会专业委员会会员、中国传媒大学客座教授。曾获首届中国鲁迅杂文奖、广东省鲁迅文艺奖、广东省有为文学奖。</p><h3 id="争议-经济学家-李剑阁-我们不能提高劳动者的工资，低工资是我们的优势。老百姓工资太高了，应该降到合理的水平"><a href="#争议-经济学家-李剑阁-我们不能提高劳动者的工资，低工资是我们的优势。老百姓工资太高了，应该降到合理的水平" class="headerlink" title="[*争议-经济学家-李剑阁] 我们不能提高劳动者的工资，低工资是我们的优势。老百姓工资太高了，应该降到合理的水平"></a>[*争议-经济学家-李剑阁] 我们不能提高劳动者的工资，低工资是我们的优势。老百姓工资太高了，应该降到合理的水平</h3><p>总结:<br>干过些实事，有钱有权有文化有地位有学识，话说得有些道理，但脱离人民，不管到底说了什么，总之没干过有害人民的事<br>2022年6月1日<br>我们不能提高劳动者的工资，低工资是我们的优势。根据过往经验来看，低价劳动力是我们的优势，所以外资才会选择我们，如果工资提高了，外资就会跑到劳动力更低的越南等东南亚国家。产业链的外移，对于我们经济发展很不利，所以一直保持低工资，一直提供低价劳动力，才能一直赚外汇。<br><a href="https://www.sohu.com/a/580028044_120913760">https://www.sohu.com/a/580028044_120913760</a><br>1.? 李剑阁并非南师大教授：<br>百科信息显示:<br>中国社会科学院研究员 中国社会科学院研究生院教授 清华大学中国经济研究中心特聘研究员 清华大学台湾研究所研究员 中国人民银行研究生部教授 南京师范大学教授 上海财经大学教授</p><p>2.? 敢言且为无声者代言的学者：<br>信息鱼龙混杂无法证实,可证实的是 有钱有权有文化<br>(孙冶方基金会理事长 前国务院发展研究中心副主任 中国社会科学院研究生院经济学硕士)</p><p>3.X断章取义 工人工资不能太高 :<br>原文为<br>2005年11月09日北京晨报道:<br>李剑阁：经济学家不能鼓吹涨工资 会使工人失业.<br>《经济学界出现1992年以来最大一次学术分歧》</p><h2 id="谣言–断章取义或凭空捏造"><a href="#谣言–断章取义或凭空捏造" class="headerlink" title="谣言–断章取义或凭空捏造"></a>谣言–断章取义或凭空捏造</h2><h3 id="谣言-浙江大学医学教授-沈岳良-说吃五花肉不长胖，只有吃米饭才长胖"><a href="#谣言-浙江大学医学教授-沈岳良-说吃五花肉不长胖，只有吃米饭才长胖" class="headerlink" title="[谣言-浙江大学医学教授-沈岳良]说吃五花肉不长胖，只有吃米饭才长胖"></a>[谣言-浙江大学医学教授-沈岳良]说吃五花肉不长胖，只有吃米饭才长胖</h3><p>教授原义: 不能忽视计量</p><h3 id="谣言-北大博士-王福重-农民不要用收割机收麦子，会污染环境"><a href="#谣言-北大博士-王福重-农民不要用收割机收麦子，会污染环境" class="headerlink" title="[谣言-北大博士-王福重] 农民不要用收割机收麦子，会污染环境"></a>[谣言-北大博士-王福重] 农民不要用收割机收麦子，会污染环境</h3><p><img src="/posts/2023/28310/%E7%8E%8B%E7%A6%8F%E9%87%8D-%E6%94%B6%E9%BA%A6%E5%AD%90.avif" alt="王福重怒骂"></p><h3 id="有专家建议-征收失业税，没工作的要交钱"><a href="#有专家建议-征收失业税，没工作的要交钱" class="headerlink" title="[有专家建议] 征收失业税，没工作的要交钱"></a>[有专家建议] 征收失业税，没工作的要交钱</h3><p>草稿</p><p>北大中文系教授臧棣回怼批评者<br>中国现代文学学会会员、武汉大学文学院副教授荣光启</p><p>科学只会被选择性采纳，需要时便是专家建议，不被需要则是谣言.</p><p>北京“明天起全面放开”？官方辟谣<br>发布日期 2022.12.3<br>相关链接 <a href="https://b23.tv/FxKzKRu">https://b23.tv/FxKzKRu</a><br>实际情况 北京后天起全面放开</p>]]></content>
    
    
    <categories>
      
      <category>持续更新中</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持续更新中</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置一个漂亮的 Windows PowerShell | Windows Terminal Preview 美化&amp;个性化</title>
    <link href="/posts/2021/39178/"/>
    <url>/posts/2021/39178/</url>
    
    <content type="html"><![CDATA[<!-- ## 完成效果 --><p><img src="/posts/2021/39178/uTools_1635574749923.png" alt="完成效果"></p><h2 id="0-准备所需文件"><a href="#0-准备所需文件" class="headerlink" title="0. 准备所需文件"></a>0. 准备所需文件</h2><ul><li><p>Windows Terminal Preview</p><ul><li>可以在 GitHub 或 Microsoft Store 获取</li></ul></li><li><p>[PowerShell] (<a href="https://aka.ms/pscore6">https://aka.ms/pscore6</a>)</p><ul><li>一个跨平台的 PowerShell</li></ul></li><li><p>[Git Bash] (<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>)</p><ul><li>可集成在 Windows Terminal Preview 中</li></ul></li></ul><h2 id="1-基础设置调整"><a href="#1-基础设置调整" class="headerlink" title="1. 基础设置调整"></a>1. 基础设置调整</h2><h3 id="开启-Terminal-亚克力半透明效果为80"><a href="#开启-Terminal-亚克力半透明效果为80" class="headerlink" title="开启 Terminal  亚克力半透明效果为80%"></a>开启 Terminal  亚克力半透明效果为80%</h3><p><img src="/posts/2021/39178/image-20211030143820010.png" alt="image-亚克力半透明效果"></p><h3 id="选择-Terminal-配色方案"><a href="#选择-Terminal-配色方案" class="headerlink" title="选择 Terminal  配色方案"></a>选择 Terminal  配色方案</h3><p>设置&gt;默认值&gt;外观&gt;配色方案</p><p>我选择 One Half Dark</p><p><img src="/posts/2021/39178/image-20211030151624811.png" alt="image-配色方案"></p><h3 id="集成-Git-Bash"><a href="#集成-Git-Bash" class="headerlink" title="集成 Git Bash"></a>集成 Git Bash</h3><h4 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Git Bash</code></pre></div><h4 id="命令行-根据安装目录而定"><a href="#命令行-根据安装目录而定" class="headerlink" title="命令行: (根据安装目录而定)"></a>命令行: (根据安装目录而定)</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:\Program Files\git\bin\bash.exe</code></pre></div><h4 id="启动目录-默认"><a href="#启动目录-默认" class="headerlink" title="启动目录: (默认)"></a>启动目录: (默认)</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">%USERPROFILE%</code></pre></div><h4 id="图标-根据安装目录而定"><a href="#图标-根据安装目录而定" class="headerlink" title="图标: (根据安装目录而定)"></a>图标: (根据安装目录而定)</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:\Program Files\git\mingw64\share\git\git-for-windows.ico</code></pre></div><h2 id="2-安装-nerd-字体"><a href="#2-安装-nerd-字体" class="headerlink" title="2. 安装 nerd 字体"></a>2. 安装 nerd 字体</h2><p>安装 nerd 以显示图标， 不然会显示为方框</p><p><a href="https://www.nerdfonts.com/font-downloads">可以在这里挑选并获取喜欢的字体</a></p><p>我选择 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/JetBrainsMono.zip">JetBrainsMono Nerd Font Mono</a></p><p><img src="/posts/2021/39178/image-20211030151437944.png" alt="image-20211030151437944"></p><p>在 Terminal  使用字体 (注意要选择带 nerd 字样的字体)</p><p>设置&gt;默认值&gt;外观&gt;字体:</p><p><img src="/posts/2021/39178/image-20211030151624811.png" alt="image-设置字体"></p><h2 id="3-主题设置"><a href="#3-主题设置" class="headerlink" title="3. 主题设置"></a>3. 主题设置</h2><p>参考: <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="“powershell.md”">[1]</span></a></sup>  </p><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><h4 id="主题美化模块-oh-my-posh"><a href="#主题美化模块-oh-my-posh" class="headerlink" title="主题美化模块 oh-my-posh"></a>主题美化模块 oh-my-posh</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Install-Module oh-my-posh -Scope CurrentUser -SkipPublisherCheck</code></pre></div><h4 id="posh-git-模块"><a href="#posh-git-模块" class="headerlink" title="posh-git 模块"></a>posh-git 模块</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Install-Module posh-git -Scope CurrentUser</code></pre></div><h4 id="增强模块-PSReadLine"><a href="#增强模块-PSReadLine" class="headerlink" title="增强模块 PSReadLine"></a>增强模块 PSReadLine</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Install-Module -Name PSReadLine -AllowPrerelease -Scope CurrentUser -Force -SkipPublisherCheck</code></pre></div><h4 id="文件图标库"><a href="#文件图标库" class="headerlink" title="文件图标库"></a>文件图标库</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Install-Module -Name Terminal-Icons -Repository PSGallery</code></pre></div><h3 id="配置-Profile-打开方式二选一"><a href="#配置-Profile-打开方式二选一" class="headerlink" title="配置 Profile (打开方式二选一)"></a>配置 Profile (打开方式二选一)</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">notepad.exe $PROFILEcode $PROFILE</code></pre></div><p>在本段中，以下操作均在 $PROFILE 文件中操作</p><p>导入主题模块和图标库</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Import-Module posh-gitImport-Module oh-my-poshImport-Module -Name Terminal-Icons</code></pre></div><h3 id="设置主题-主题库"><a href="#设置主题-主题库" class="headerlink" title="设置主题 (主题库)"></a>设置主题 (<a href="https://ohmyposh.dev/docs/themes">主题库</a>)</h3><p>我选择使用 <a href="https://ohmyposh.dev/docs/themes#m365princess">M365Princess</a>主题</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Set-PoshPrompt -Theme M365Princess</code></pre></div><h3 id="自动补全和提示"><a href="#自动补全和提示" class="headerlink" title="自动补全和提示"></a>自动补全和提示</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete</code></pre></div><p>完成后记得保存</p><h3 id="以下为完整文件及截图"><a href="#以下为完整文件及截图" class="headerlink" title="以下为完整文件及截图"></a>以下为完整文件及截图</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Import-Module posh-gitImport-Module oh-my-poshSet-PoshPrompt -Theme M365PrincessSet-PSReadlineKeyHandler -Key Tab -Function MenuComplete</code></pre></div><p><img src="/posts/2021/39178/Snipaste_2021-10-30_15-07-33.png" alt="完整文件截图"></p><h3 id="重新打开-Terminal"><a href="#重新打开-Terminal" class="headerlink" title="重新打开 Terminal"></a>重新打开 Terminal</h3><h2 id="完成啦-0-◇-0-x2F"><a href="#完成啦-0-◇-0-x2F" class="headerlink" title="完成啦(0^◇^0)&#x2F;"></a>完成啦(0^◇^0)&#x2F;</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://gist.github.com/xiaopeng163/0fe4225a56ff97cd47e25a4b8a6f36ec">“powershell.md”</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>PowerShell</tag>
      
      <tag>美化&amp;个性化</tag>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/2021/3eeb/"/>
    <url>/posts/2021/3eeb/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
