<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/favicon.ico"><link rel="icon" href="/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yuhanawa"><meta name="keywords" content=""><meta name="description" content="🌸 樱花开头的内容为译者添加🌸 翻译自 LALRPOP 教程 | 学习手册&#x2F;教程&#x2F;文档 | Tutorial🌸 导航: &lt;&lt;[上篇-快速开始] - [目录] - [下篇-高级设置]&gt;&gt;🌸 原文共9节,译文合为一页,本章目录在右侧   序言 | Index这是一个关于如何使用 LALRPOP 编写一个简单的计算器的完整的解析器的教程.  如果你不熟"><meta property="og:type" content="article"><meta property="og:title" content="LALRPOP Tutorial 教程&#x2F;文档-中文翻译 | LALRPOP Tutorial Chinese Book | LALRPOP是Rust写的解析器生成器"><meta property="og:url" content="http://yuhanawa.github.io/posts/2023/57877/index.html"><meta property="og:site_name" content="Yuhan &#39;s blog"><meta property="og:description" content="🌸 樱花开头的内容为译者添加🌸 翻译自 LALRPOP 教程 | 学习手册&#x2F;教程&#x2F;文档 | Tutorial🌸 导航: &lt;&lt;[上篇-快速开始] - [目录] - [下篇-高级设置]&gt;&gt;🌸 原文共9节,译文合为一页,本章目录在右侧   序言 | Index这是一个关于如何使用 LALRPOP 编写一个简单的计算器的完整的解析器的教程.  如果你不熟"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-01-25T11:00:00.000Z"><meta property="article:modified_time" content="2023-07-28T14:12:56.015Z"><meta property="article:author" content="Yuhanawa"><meta property="article:tag" content="LALRPOP"><meta property="article:tag" content="Rust"><meta property="article:tag" content="翻译"><meta property="article:tag" content="教程"><meta name="twitter:card" content="summary_large_image"><title>LALRPOP Tutorial 教程/文档-中文翻译 | LALRPOP Tutorial Chinese Book | LALRPOP是Rust写的解析器生成器 - Yuhan &#39;s blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/prism/1.26.0/plugins/line-numbers/prism-line-numbers.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"yuhanawa.github.io",root:"/",version:"1.9.0",typing:{enable:!0,typeSpeed:70,cursorChar:"",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!1,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"sbyNAuxQBqjq3uoMduSWbIhb-gzGzoHsz",app_key:"pCKWRQnCJ9vokdYUmvsWlrLw",server_url:"https://sbynauxq.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yuhanawa</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="LALRPOP Tutorial 教程/文档-中文翻译 | LALRPOP Tutorial Chinese Book | LALRPOP是Rust写的解析器生成器"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Yuhanawa </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-01-25 19:00" pubdate>2023年1月25日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 19k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 158 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">LALRPOP Tutorial 教程/文档-中文翻译 | LALRPOP Tutorial Chinese Book | LALRPOP是Rust写的解析器生成器</h1><div class="markdown-body"><p>🌸 樱花开头的内容为译者添加<br>🌸 翻译自 <a target="_blank" rel="noopener" href="http://lalrpop.github.io/lalrpop/tutorial/index.html">LALRPOP 教程 | 学习手册&#x2F;教程&#x2F;文档 | Tutorial</a><br>🌸 导航: <strong><a href="https://yuhanawa.github.io/posts/2023/17808/">&lt;&lt;[上篇-快速开始]</a> - <a href="https://yuhanawa.github.io/posts/2023/11467/">[目录]</a> - <a href="https://yuhanawa.github.io/posts/2023/21239/">[下篇-高级设置]&gt;&gt;</a></strong><br>🌸 原文共9节,译文合为一页,本章目录在右侧</p><md id="00"><h2 id="序言-Index"><a href="#序言-Index" class="headerlink" title="序言 | Index"></a>序言 | Index</h2><p>这是一个关于如何使用 LALRPOP 编写一个简单的计算器的完整的解析器的教程.</p><p>如果你不熟悉什么是解析器生成器(parser generator), 你应该先阅读<a href="https://yuhanawa.github.io/posts/2023/51562/">解析器基础速成 | Crash course on parsers</a>.</p><p>本教程仍然不完整. 如果有时间会再写以下内容:</p><ul><li>关于解决 shift-reduce 和 reduce-reduce 冲突的建议</li><li>向 Action Code 传递 状态和类型&#x2F;生命周期 参数 (see e.g. <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/expr_arena.lalrpop">this test</a> invoked <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/lib.rs">from here</a>).</li><li>使用 <code>@L</code> 和<code>@R</code> 进行位置跟踪 (see e.g. <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/intern_tok.lalrpop">this test</a>).</li><li>与外部标记器(tokenizers)集成 (see e.g. <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/expr.lalrpop">this test</a> invoked <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/lib.rs">from here</a>).</li><li>有条件的宏 (目前还没有好的测试, sorry)</li><li>返回 <code>Result</code> 的代码容易发生的错误 (see e.g. <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/error.lalrpop">this test</a> invoked <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/lib.rs">from here</a>).</li><li>转换为使用 <code>LALR(1)</code> 替代 <code>LR(1)</code> (see e.g. <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/expr_lalr.lalrpop">this test</a> invoked <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/lib.rs">from here</a>).</li><li>未来一些功能的计划</li></ul><p>🌸 但这篇教程已经13个月没有更新了 (ノ｀Д)ノ</p><md id="01"><h2 id="1-添加-LALRPOP-到-Cargo-toml-Adding-LALRPOP-to-your-Cargo-toml-file"><a href="#1-添加-LALRPOP-到-Cargo-toml-Adding-LALRPOP-to-your-Cargo-toml-file" class="headerlink" title="[1]添加 LALRPOP 到 Cargo.toml|Adding LALRPOP to your Cargo.toml file"></a>[1]添加 LALRPOP 到 <code>Cargo.toml</code>|Adding LALRPOP to your <code>Cargo.toml</code> file</h2><p>🌸 这篇是<del><em>一些废话</em></del> LALRPOP 的一些介绍和大致上<a href="https://yuhanawa.github.io/posts/2023/17808/">快速开始</a>的详细版本<br>🌸 可以快速浏览甚至<a href="#02">跳过到02</a> (记住此时的自信(￣y▽,￣)╭ )</p><p>LALRPOP 作为一个预处理器, 可以与 Cargo 在一起工作. 当 LALRPOP 被调用时, 它会在源代码目录中搜索扩展名为 <code>lalrpop</code> 的文件并创建相应的 <code>rs</code> 文件. 例如, 如果我们有一个 <code>calculator.lalrpop</code> 的文件, 预处理程序会创建一个Rust文件 <code>calculator.rs</code>.<br>顺便说一下, LALRPOP 的语法有意接近于 Rust, 所以应该可以使用Rust的拓展插件来编辑 lalrpop 文件. 只要它不太挑剔(emacs 的 rust-mode 就可以很好地工作).</p><p>首先, 让我们使用 <code>cargo new</code> 来建立一个新的项目. 我们把它叫做<br><code>calculator</code> (计算器):</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; cargo new --bin calculator</code></pre></div><p>我们现在需要编辑生成的 <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/Cargo.toml"><code>calculator/Cargo.toml</code></a> 文件来调用 LALRPOP 预处理程序. 生成的文件应该长这样:</p><div class="code-wrapper"><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[package]
name &#x3D; &quot;calculator&quot;
version &#x3D; &quot;0.1.0&quot;
authors &#x3D; [&quot;Niko Matsakis &lt;niko@alum.mit.edu&gt;&quot;]

[build-dependencies] # &lt;-- 我们添加了这行和后面的内容! 
lalrpop &#x3D; &quot;0.19.8&quot;

[dependencies]
lalrpop-util &#x3D; &quot;0.19.8&quot;
regex &#x3D; &quot;1&quot;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-lalrpop" data-language="lalrpop"><code class="language-lalrpop">use std::str::FromStr;

grammar;

pub Term: i32 &#x3D; &#123;
    &lt;n:Num&gt; &#x3D;&gt; n,
    &quot;(&quot; &lt;t:Term&gt; &quot;)&quot; &#x3D;&gt; t,
&#125;;

Num: i32 &#x3D; &lt;s:r&quot;[0-9]+&quot;&gt; &#x3D;&gt; i32::from_str(s).unwrap();</code></pre></div><p>Cargo 可以运行 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripts</a> 作为预处理步骤. 默认名为 “build.rs”. <code>[build-dependencies]</code> 部分指定了构建脚本的依赖项 – 在本例中, 只有 LALRPOP .</p><p><code>[dependencies]</code> 部分描述了 LALRPOP 在运行时需要的依赖项. 所有的 LALRPOP 项目必须添加 <code>lalrpop-util</code> crate. 此外, 如果你不想手动编写词法分析器(lexer), 你需要添加 <code>regex</code> crate 作为依赖. (如果你不知道什么是词法器, 不要担心, 这并不重要. 因为我们将在<a href="#02">下一节-解析数字</a>中介绍它. 如果你<em>知道</em>什么是词法分析器, 并且你想知道如何用手写一个词法分析器并在 LALRPOP 中使用它, 那么请查看<a href="(http://lalrpop.github.io/lalrpop/lexer_tutorial/index.html)">词法分析器教程 | lexer tutorial</a>(链接为原文档, 未翻译)).</p><p>接下来我们要添加 <code>build.rs</code> 文件. 对于那些不熟悉<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">该功能</a>(🌸 指<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripts</a>)的人, <code>build.rs</code> 文件应该放在你的 <code>Cargo.toml</code> 文件旁边, 而不是与你的 Rust 代码放在 <code>src</code> 文件夹下, <code>build.rs</code> 应该是下面的样子:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">extern crate lalrpop;

fn main() &#123;
    lalrpop::process_root().unwrap();
&#125;</code></pre></div><p>函数 <code>process_root</code> 会处理你的 <code>src</code> 目录, 将所有 <code>lalrpop</code> 文件转换为 <code>rs</code> 文件. 它非常聪明, 可以检查时间戳, 如果 <code>rs</code> 文件比 <code>lalrpop</code> 文件新, 则不进行任何操作并将生成的 <code>rs</code> 文件标记为只读. 它返回一个 <code>io::Result&lt;()&gt;</code> , 所以 <code>unwrap()</code> 调用只是断言没有发生文件系统错误发生.</p><p><strong>NOTE:</strong> 在Windows上, 必要的API还不稳定, 所以时间戳检查被禁用.<br>🌸 这个NOTE写于数年前, 请以具体情况为准. <del><em>我也不知道具体情况如何,只是善意的提个醒</em></del></p><md id="02"><h2 id="2-解析-括号内的-数字-Parsing-parenthesized-numbers"><a href="#2-解析-括号内的-数字-Parsing-parenthesized-numbers" class="headerlink" title="[2]解析(括号内的)数字|Parsing parenthesized numbers"></a>[2]解析(括号内的)数字|Parsing parenthesized numbers</h2><p>OK, 现在我们已经准备好开始编写一个 LALRPOP 语法了. 在我们处理完整的表达式之前, 让我们从简单的东西开始 – 真的超级简单. 让我们从括号内的整数开始, 比如 <code>123</code> 或 <code>(123)</code> , 甚至是 <code>(((123))</code>. Wow.</p><p>为了处理这个问题, 我们需要添加一个<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator1.lalrpop"><code>calculator1.lalrpop</code></a>, 如下所示. 注意:为了解释起来更容易, 这个是最完整的代码. 下一节将通过采用 LALRPOP 提供的一些简便方法(shorthands)使其更简洁.</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use std::str::FromStr;

grammar;

pub Term: i32 &#x3D; &#123;
    &lt;n:Num&gt; &#x3D;&gt; n,
    &quot;(&quot; &lt;t:Term&gt; &quot;)&quot; &#x3D;&gt; t,
&#125;;

Num: i32 &#x3D; &lt;s:r&quot;[0-9]+&quot;&gt; &#x3D;&gt; i32::from_str(s).unwrap();</code></pre></div><p>让我们一点一点地看一下. 文件的第一部分是 <code>use</code> 语句和 <code>grammar</code> 语句. 你会在每个 LALRPOP 语法的顶部找到它们. 就像在 Rust 中一样, <code>use</code> 语句只是用来导入文件 事实上, 这些 <code>use</code> 语句只是根据需要复制到生成的 Rust 代码中.</p><p><em>关于下划线和衍生文件的说明:</em> LALRPOP 生成的自己的名字至少有两个前导下划线. 为了避免冲突, 如果它看到你使用的标识符也有两个下划线, 它将添加更多的下划线. 但是如果你使用全局导入以<code>__</code>开头的文件, 你可能会发现存在冲突. 为了避免这种情况, 不要使用全局导入(或者在其他地方定义一些带有两个下划线的名字).</p><p><strong>非终结符声明</strong>在 <code>grammar</code> 声明完后是一堆的<em>非终结符声明</em>. 这个语法有两个非终结符, <code>Term</code> 和 <code>Num</code>. 非终结符只是我们给可以被解析的东西起的一个名字, 然后根据其他内容定义每个非终结符.</p><p>让我们从文件末尾的 <code>Num</code> 开始, 它的声明如下.</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D;
    &lt;s:r&quot;[0-9]+&quot;&gt; &#x3D;&gt; i32::from_str(s).unwrap();</code></pre></div><p>此声明表示 <code>Num</code> 的类型为 <code>i32</code> . 这意味着当我们从输入文本中解析一个 <code>Num</code> 时, 我们将生成一个类型为<code>i32</code>的值. <code>Num</code>的定义是 <code>&lt;s:r&quot;[0-9]+&quot;&gt;</code> . 让我们从内到外看仔细一下. 符号 <code>r&quot;[0-9]+&quot;</code> 是一个正则表达式——这与Rust原始字符串相同. (而且, 跟在Rust中一样, 如果需要嵌入引号, 可以使用 hashes, 例如 <code>r#&quot;...&quot;...&quot;#</code>)它将与符合正则表达式的字符串相匹配: 在本例中是一些数字. 这个匹配的结果是我们正在解析的输入文本中的一个切片(slice) <code>&amp;&#39;input str</code>(引用,不作复制).</p><p>此正则表达式用尖括号括起来并标记为: <code>&lt;s:r&quot;[0-9]+&quot;&gt;</code>. 通常, 在 LALRPOP 中使用尖括号来表示将在<em>动作代码(Action Code)</em>(指解析<code>Num</code>时执行的代码)使用的值, 在本例中, 与正则表达式匹配的字符串绑定到变量<code>s</code>, <code>i32::from_str(s).unwrap()</code> 会解析该字符串创建并返回一个 <code>i32</code>.</p><p>OK, 现在我们来看看非终结符 <code>Term</code>.</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub Term: i32 &#x3D; &#123;
    &lt;n:Num&gt; &#x3D;&gt; n,
    &quot;(&quot; &lt;t:Term&gt; &quot;)&quot; &#x3D;&gt; t,
&#125;;</code></pre></div><p>首先, 此非终结符声明为 <code>pub</code>. 这意味着 LALRPOP 将生成一个公共结构(正如我们将看到的, 命名为 <code>TermParser</code>), 您可以使用它将字符串解析为 <code>Term</code> . 私有非终结符(如<code>Num</code>)只能在语法本身内部使用, 不能从外部使用. <code>Term</code> 非终结符有两个可供选择的定义, 可以用 <code>&#123; alternative1, alternative2 &#125;</code> 来表示. 在这个例子中, 第一个选项是 <code>&lt;n:Num&gt;</code>, 这表示 <code>Term</code> 可以是一个数字. 所以<code>22</code>是一个 <code>Term</code> . 第二个选择是 <code>&quot;(&quot; &lt;t:Term&gt; &quot;)&quot;</code>, 表示 <code>Term</code> 也可以是带括号的 <code>Term</code>, 所以 <code>(22)</code> 是 <code>Term</code>, <code>((22))</code>, <code>((((((22))))))</code> 等也是<code>Term</code></p><p><strong>调用解析器</strong> OK, 我们编写了解析器, 该如何使用它呢? 对于每个声明为 <code>pub</code> 的非终结符 <code>Foo</code>, LALRPOP 将通过 <code>parse</code> 方法导出 <code>FooParser</code> 结构, 您可以调用该方法将字符串解析为该非终结符. 下面是我们通过添加到<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/main.rs"><code>main.rs</code></a>文件中的一个简单测试来使用此结构来测试我们的 <code>Term</code> 非终结符:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[macro_use] extern crate lalrpop_util;

lalrpop_mod!(pub calculator1); &#x2F;&#x2F; synthesized by LALRPOP

#[test]
fn calculator1() &#123;
    assert!(calculator1::TermParser::new().parse(&quot;22&quot;).is_ok());
    assert!(calculator1::TermParser::new().parse(&quot;(22)&quot;).is_ok());
    assert!(calculator1::TermParser::new().parse(&quot;((((22))))&quot;).is_ok());
    assert!(calculator1::TermParser::new().parse(&quot;((22)&quot;).is_err());
&#125;</code></pre></div><p>parse 方法的完整签名如下所示:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">fn parse&lt;&#39;input&gt;(&amp;self, input: &amp;&#39;input str)
                     -&gt; Result&lt;i32, ParseError&lt;usize,(usize, &amp;&#39;input str),()&gt;&gt;
                     &#x2F;&#x2F;        ~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     &#x2F;&#x2F;         |                       |
                     &#x2F;&#x2F; Result upon success             |
                     &#x2F;&#x2F;                                 |
                     &#x2F;&#x2F;             Error enum defined in the lalrpop_util crate
&#123;
    ...
&#125;</code></pre></div><md id="03"><h2 id="3-类型推断-Type-inference"><a href="#3-类型推断-Type-inference" class="headerlink" title="[3]类型推断|Type inference"></a>[3]类型推断|Type inference</h2><p>OK, 现在我们理解了<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator1.lalrpop">the calculator1 example</a>, 让我们通过 LALRPOP 提供的一些简便方法来使代码更加简洁, 这段代码可以在<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator2.lalrpop">the calculator2 demo</a>中找到.</p><p>首先, 让我们看看我们之前 <code>Term</code> 的定义:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub Term: i32 &#x3D; &#123;
    &lt;n:Num&gt; &#x3D;&gt; n,
    &quot;(&quot; &lt;t:Term&gt; &quot;)&quot; &#x3D;&gt; t,
&#125;;</code></pre></div><p>这里的动作代码(ActionCode)有点儿意思. 在这两种情况下, 它都没有做任何新的工作, 只是选择一个由另一个非终结符产生的值. 事实上, 这很常见. 所以 LALRPOP 为其提供了一些简便方法, 这是<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator2.lalrpop">the calculator2 demo</a>中 <code>Term</code> 的定义:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub Term &#x3D; &#123; Num, &quot;(&quot; &lt;Term&gt; &quot;)&quot; &#125;;</code></pre></div><p>在这里根本就没有动作代码(ActionCode). 如果没有动作代码, LALRPOP 就会自动生成动作代码, 取被匹配事物的值. 在第一个选项 <code>Num</code> 的情况下, 只有一个匹配项被匹配, 所以这表明无论 <code>Term</code> 的值是什么, 都与我们解析的 <code>Num</code> 的值相同.</p><p>在第二个选项中, <code>&quot;(&quot; &lt;Term&gt; &quot;)&quot;</code>, 有三个字符(串)被匹配. 在这里, 我们用角括号来选择我们要取的值 — 我们只选择了一个值, 所以我们取了我们解析的 <code>Term</code> 的值. 如果我们选择了一个以上的值, 那么结果将是所有选择的值的一个元组. 如果我们没有选择任何值(即 <code>&quot;(&quot; Term &quot;)&quot;</code> ), 结果将是所有值的一个元组, 所以返回类型是 <code>(&amp;&#39;input str, i32, &amp;&#39;input str)</code>.</p><p>说到类型, 你可能已经注意到 <code>Term</code> 没有类型注释. 由于我们没有编写动作代码, 我们可以省略类型注释, 让 LALRPOP 为我们推断. 在此例中, LALRPOP 会推测 <code>Term</code> 与 <code>Num</code> 必须具有相同的类型, 因此类型必须是<code>i32</code>.</p><p>OK, 让我们看看之前在<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator1.lalrpop">calculator1</a>中看到的 <code>Num</code> 的定义.</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D; &lt;s:r&quot;[0-9]+&quot;&gt; &#x3D;&gt; i32::from_str(s).unwrap();</code></pre></div><p>这个定义也可以做得更短一些. 在<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator2.lalrpop">calculator2</a>,你会发现:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D; r&quot;[0-9]+&quot; &#x3D;&gt; i32::from_str(&lt;&gt;).unwrap();</code></pre></div><p>在这里, 我们没有将<code>s</code>赋值为正则表达式的匹配结果, 而是修改了动作代码(ActionCode), 使用了简短的表达式 <code>&lt;&gt;</code> . 这是一个简便方法, 表示 <ruby>synthesize names for the matched values and insert a comma-separated list here<rt>引号为原文自带 AI翻译:为匹配的值合成名称,并在此插入以逗号分隔的列表</rt></ruby> 在此例中, 只有一个匹配值, <code>r&quot;[0-9]+&quot;</code>, 它返回一个<code>&amp;&#39;input str&#39;</code>, 所以 LALRPOP 将为该值插入一个生成的变量. 注意, 我们仍然有自定义的动作代码, 所有仍然需要类型注释.</p><p>要控制在动作代码中使用<code>&lt;&gt;</code> 表达式时选择的值, 可以使用前面看到的尖括号. 以下是一些示例可供参考, 以便利于用你自己的想法去拓展它们:</p><table><thead><tr><th>Alternative</th><th>Equivalent to</th></tr></thead><tbody><tr><td><code>A =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;a:A&gt; =&gt; bar(a)</code></td></tr><tr><td><code>A B =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;a:A&gt; &lt;b:B&gt; =&gt; bar(a, b)</code></td></tr><tr><td><code>A B =&gt; (&lt;&gt;)</code></td><td><code>&lt;a:A&gt; &lt;b:B&gt; =&gt; (a, b)</code></td></tr><tr><td><code>&lt;A&gt; B =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;a:A&gt; B =&gt; bar(a)</code></td></tr><tr><td><code>&lt;p:A&gt; B =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;p:A&gt; B =&gt; bar(p)</code></td></tr><tr><td><code>&lt;A&gt; &lt;B&gt; =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;a:A&gt; &lt;b:B&gt; =&gt; bar(a, b)</code></td></tr><tr><td><code>&lt;p:A&gt; &lt;q:B&gt; =&gt; bar(&lt;&gt;)</code></td><td><code>&lt;p:A&gt; &lt;q:B&gt; =&gt; bar(p, q)</code></td></tr><tr><td><code>&lt;p:A&gt; B =&gt; Foo &#123;&lt;&gt;&#125;</code></td><td><code>&lt;p:A&gt; B =&gt; Foo &#123;p:p&#125;</code></td></tr><tr><td><code>&lt;p:A&gt; &lt;q:B&gt; =&gt; Foo &#123;&lt;&gt;&#125;</code></td><td><code>&lt;p:A&gt; &lt;q:B&gt; =&gt; Foo &#123;p:p, q:q&#125;</code></td></tr></tbody></table><p>表达式也适用于结构构造函数(如上面例子中的<code>Foo &#123;...&#125;</code>). 如果解析值的名称与结构字段的名称相匹配时效果会很好.</p><md id="04"><h2 id="4-处理完整的表达式-Handling-full-expressions"><a href="#4-处理完整的表达式-Handling-full-expressions" class="headerlink" title="[4]处理完整的表达式|Handling full expressions"></a>[4]处理完整的表达式|Handling full expressions</h2><p>现在我们准备扩展我们的计算器来处理完整的算术表达式(至少涵盖了你小学学习的表达式). 下面是 <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator3.lalrpop">下一节的计算器示例,calculator3</a>:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use std::str::FromStr;

grammar;

pub Expr: i32 &#x3D; &#123;
    &lt;l:Expr&gt; &quot;+&quot; &lt;r:Factor&gt; &#x3D;&gt; l + r,
    &lt;l:Expr&gt; &quot;-&quot; &lt;r:Factor&gt; &#x3D;&gt; l - r,
    Factor,
&#125;;

Factor: i32 &#x3D; &#123;
    &lt;l:Factor&gt; &quot;*&quot; &lt;r:Term&gt; &#x3D;&gt; l * r,
    &lt;l:Factor&gt; &quot;&#x2F;&quot; &lt;r:Term&gt; &#x3D;&gt; l &#x2F; r,
    Term,
&#125;;

Term: i32 &#x3D; &#123;
    Num,
    &quot;(&quot; &lt;Expr&gt; &quot;)&quot;,
&#125;;

Num: i32 &#x3D; &#123;
    r&quot;[0-9]+&quot; &#x3D;&gt; i32::from_str(&lt;&gt;).unwrap(),
&#125;;</code></pre></div><p>这个示例最有趣的地方在于它如何编码优先级. 优先级的概念当然是在像<code>2+3*4</code>这样的表达式中,我们需要先乘除后加减. 但 LALRPOP 没有内置的功能来给运算符赋予优先级,主要是因为我认为这些功能有些可怕(creepy),不过在语法中通过分层结构来实现优先级还是相当简单的 —— 例如,非终结符<code>Expr</code>涵盖所有的表达式. 它由一系列相互加减的<code>Factor</code>(因子)组成. 一个<code>Factor</code>就是一系列被乘或除的项. 最终,<code>Term</code>是一个单独的数字或一个用括号包裹的完整的表达式.</p><p>从这个例子出发, 编码优先级的典型模式是有每个优先级对于一个非终端符,从最低优先级的运算符 (<code>+</code>, <code>-</code>) 开始,然后加入下一个优先级 (<code>*</code>, <code>/</code>) , 最后加入像 <code>Num</code> 这样的 “atomic(原子)” 表达式. 最后,在atomic表达式中加入括号包裹起来的顶级非终结符(top-level),这样可以让人们重复这段操作来设置下一个优先级(which lets people reset.)</p><p>要知道为什么这样做, 请考虑像 <code>2+3*4</code> 有两种可能的解析树:</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">2 + 3   *    4          2   +  3   *    4
| | |   |    |          |   |  |   |    |
| | +-Factor-+    OR    +-Expr-+   |    |
| |     |                   |      |    |
+-Expr -+                   +----Factor-+</code></pre></div><p>在第一种中,我们给乘法更高的优先级,在第二个种,我们(错误地)给加法更高的优先级. 如果你现在看一下语法, 你会发现第二种是不可能的: <code>Factor</code> 不能包含 <code>Expr</code> 作为其组成成分. 这就是分层结构的目的:迫使解析器采取你想要的优先级.</p><p>最后,请注意我们只在我们需要解析的的非终结符(<code>Expr</code>)之前写<code>pub</code>,而不是所有. 标记为<code>pub</code>的非终结符会生成额外的代码, 比如可以从其他模块访问解析器调用的<code>new()</code>方法. 如果你<code>pub</code>了不需要<code>pub</code>的非终结符, 你得到一个关于<code>FooParser</code>的未使用<code>new()</code>方法的警告,请从非终结符<code>Foo</code>中删除<code>pub</code>.</p><md id="05"><h2 id="5-构建AST抽象语法树-Building-ASTs"><a href="#5-构建AST抽象语法树-Building-ASTs" class="headerlink" title="[5]构建AST抽象语法树|Building ASTs"></a>[5]构建AST抽象语法树|Building ASTs</h2><p>大多数时候,当你进行解析时,你并不希望计算一个值,你是想构建某种数据结构. 下面是一个简单的例子来说明在 LALRPOP 中是如何做到这一点的. 首先, 我们需要<em>定义</em>我们将要构建的数据结构. 我们将构建一个非常简单的 <code>enum</code>:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub enum Expr &#123;
    Number(i32),
    Op(Box&lt;Expr&gt;, Opcode, Box&lt;Expr&gt;),
&#125;

pub enum Opcode &#123;
    Mul,
    Div,
    Add,
    Sub,
&#125;</code></pre></div><p>我们将此代码放入项目中的<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/ast.rs"><code>ast.rs</code>模块</a>中,并为它添加 <code>Debug</code>impl 以便更好地打印输出. 现在我们将创建<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator4.lalrpop">calculator4</a>示例,它将用来构建这个语法树. 首先,让我们只看<code>Expr</code>非终结符,它将向你展示它是如何完成的大部分内容(最有趣的几行已经用注释标出):</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use std::str::FromStr;
use ast::&#123;Expr, Opcode&#125;; &#x2F;&#x2F; (0)

grammar;

pub Expr: Box&lt;Expr&gt; &#x3D; &#123; &#x2F;&#x2F; (1)
    Expr ExprOp Factor &#x3D;&gt; Box::new(Expr::Op(&lt;&gt;)), &#x2F;&#x2F; (2)
    Factor,
&#125;;

ExprOp: Opcode &#x3D; &#123; &#x2F;&#x2F; (3)
    &quot;+&quot; &#x3D;&gt; Opcode::Add,
    &quot;-&quot; &#x3D;&gt; Opcode::Sub,
&#125;;</code></pre></div><p>首先,我们必须通过添加 <code>use</code> 语句将这些新名称导入文件(0). 接下来,我们想生成<code>Box&lt;Expr&gt;</code> 值,所以我们将<code>Expr</code>(以及<code>Factor</code>和<code>Term</code>)的类型更改为<code>Box&lt;Expr&gt;</code>(1). 相应的动作代码在(2)中更改;这里我们使用<code>&lt;&gt;</code>扩展来为<code>Expr::Op</code>提供三个参数. 最后,为了简洁,我们引入了一个<code>ExprOp</code>非终结符(3)来覆盖两个动作代码,现在它们触发相同的动作代码(之前它们触发不同的动作代码).</p><p><code>Factor</code>的定义以类似的方式进行了转换:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Factor: Box&lt;Expr&gt; &#x3D; &#123;
    Factor FactorOp Term &#x3D;&gt; Box::new(Expr::Op(&lt;&gt;)),
    Term,
&#125;;

FactorOp: Opcode &#x3D; &#123;
    &quot;*&quot; &#x3D;&gt; Opcode::Mul,
    &quot;&#x2F;&quot; &#x3D;&gt; Opcode::Div,
&#125;;</code></pre></div><p>最后,我们调整<code>Term</code>和<code>Num</code>的定义. 在<code>Num</code>转化到<code>Term</code>时,我们将原始的<code>i32</code>转换为<code>Box &lt; Expr &gt;</code>(4):</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Term: Box&lt;Expr&gt; &#x3D; &#123;
    Num &#x3D;&gt; Box::new(Expr::Number(&lt;&gt;)), &#x2F;&#x2F; (4)
    &quot;(&quot; &lt;Expr&gt; &quot;)&quot;
&#125;;

Num: i32 &#x3D; &#123;
    r&quot;[0-9]+&quot; &#x3D;&gt; i32::from_str(&lt;&gt;).unwrap()
&#125;;</code></pre></div><p>现在我们可以通过向我们的<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/main.rs">main.rs</a>文件添加一些代码来测试它,该代码会解析一个表达式并使用 <code>Debug</code> impl 格式化打印输出:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">lalrpop_mod!(pub calculator4);
pub mod ast;

#[test]
fn calculator4() &#123;
    let expr &#x3D; calculator4::ExprParser::new()
        .parse(&quot;22 * 44 + 66&quot;)
        .unwrap();
    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;((22 * 44) + 66)&quot;);
&#125;</code></pre></div><md id="06"><h2 id="6-宏-Macros"><a href="#6-宏-Macros" class="headerlink" title="[6]宏|Macros"></a>[6]宏|Macros</h2><p>在写语法时, 我们经常会遇到一些重复的结构,这时我们会进行复制粘贴. 一个常见的例子是定义类似 “逗号分隔的列表” 的东西. 假设我们想解析逗号分隔的表达式列表(当然,还有可选的尾随逗号). 如果我们要完整地写出来,它会看起来像:</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Exprs: Vec&lt;Box&lt;Expr&gt;&gt; &#x3D; &#123;   
    Exprs &quot;,&quot; Expr &#x3D;&gt; ..., 
    Expr &#x3D;&gt; vec![], 
&#125;</code></pre></div><p>当然,这并没有处理尾随逗号,而且我省略了动作代码. 如果我们加上这些, 它会变得更复杂. 到目前为止, 这很好, 但是之后我们还想要逗号分隔的术语列表怎么办?我们只能靠复制粘贴吗?</p><p>LALRPOP 提供了一个更好的选择. 你可以定义宏. 实际上,LALRPOP内置了四个宏: <code>*</code>, <code>?</code>, <code>+</code>, <code>(...)</code>. 例如, 你可以使用<code>Expr?</code>表示 “一个可选的<code>Expr</code>“. 这将使类型变为<code>Option&lt;Box&lt;Expr&gt;&gt;</code>(因为<code>Expr</code>本身的类型就是<code>Box&lt;Expr&gt;</code>). 类似的, 你可以通过写<code>Expr*</code>或<code>Expr+</code>来得到一个<code>Vec&lt;Expr&gt;</code>(最小长度分别为0和1). 最后一个宏是括号, 它是创建一个新的非终端符的简写. 这让你可以写出像<code>(&lt;Expr&gt; &quot;,&quot;)?</code>这样的东西来表示”可选地解析一个后面带有一个逗号的<code>Expr</code>“. 请注意<code>Expr</code>周围的角括号: 这些确保<code>(&lt;Expr&gt; &quot;,&quot;)</code>的值是表达式的值, 而不是表达式和逗号的元组. 这意味着<code>(&lt;Expr&gt; &quot;,&quot;)?</code>的类型是<code>Option&lt;Box&lt;Expr&gt;&gt;</code> (而不是 <code>Option&lt;(Box&lt;Expr&gt;, &amp;&#39;input str)&gt;</code>).</p><p>使用这些操作,我们可以使用宏<code>Comma&lt;T&gt;</code>定义<code>Exprs</code>来创建<code>T</code>的逗号分隔列表,不管<code>T</code>是什么类型(此定义出现在<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator5.lalrpop">calculator5</a>中):</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub Exprs &#x3D; Comma&lt;Expr&gt;; &#x2F;&#x2F; (0)

Comma&lt;T&gt;: Vec&lt;T&gt; &#x3D; &#123; &#x2F;&#x2F; (1)
    &lt;mut v:(&lt;T&gt; &quot;,&quot;)*&gt; &lt;e:T?&gt; &#x3D;&gt; match e &#123; &#x2F;&#x2F; (2)
        None &#x3D;&gt; v,
        Some(e) &#x3D;&gt; &#123;
            v.push(e);
            v
        &#125;
    &#125;
&#125;;</code></pre></div><p>第(0)行的<code>Exprs</code>定义相当明显, 它只使用了 <code>Comma&lt;Expr&gt;</code>宏. 让我们看看第(1)行的<code>Comma&lt;T&gt;</code>的定义. 这有点紧凑, 所以让我们把它先拆开. 首先, <code>T</code>是某个终结符或非终结符. 但请注意我们也可以将其用作类型: 当宏展开时, 类型中的<code>T</code>将被替换成”不管<code>T</code>是什么类型”.</p><p>接下来,在(2)中,我们解析 <code>&lt;mut v:(&lt;T&gt; &quot;,&quot;)*&gt; &lt;e:T?&gt;</code> .</p><p>这里有很多符号, 所以我们先去掉所有的尖括号, 这些角括号只是用来告诉LALRPOP你想传递哪些值, 哪些值要丢弃. 去除一些符号后变成了<code>(T &quot;,&quot;)* T?</code>.<br>希望您可以看出这是匹配一个带有可选尾随逗号的逗号分隔列表. 现在让我们把这些尖括号加回来. 在包裹在小括号中,我们得到 <code>(&lt;T&gt; &quot;,&quot;)*</code> – 这只意味着我们保留<code>T</code>的值, 但在构建我们的向量时丢弃逗号的值. 然后我们捕获该向量并将其称为 <code>v</code>: <code>&lt;mut v:(&lt;T&gt; &quot;,&quot;)*&gt;</code>,<code>mut</code>使<code>v</code>在动作代码中是可变的. 最后, 我们捕获了可选的尾部元素<code>e</code>: <code>&lt;e:T?&gt;</code>. 这意味着Rust代码有两个可用的变量, <code>v: Vec&lt;T&gt;</code> 和 <code>e: Option&lt;T&gt;</code>. 在动作代码本身应该是相当清楚的 – 如果<code>e</code>是<code>Some</code>, 它就把它追加到Vec中并返回结果.</p><p>作为使用宏的另一个例子, 你可能记得我们在<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator4.lalrpop">calculator4</a>中看到的优先级层(<code>Expr</code>, <code>Factor</code>, 等等), 它有一种重复的结构. 你可以用一个宏将其分解. 在这种情况下, 它是一个递归宏:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Tier&lt;Op,NextTier&gt;: Box&lt;Expr&gt; &#x3D; &#123;
    Tier&lt;Op,NextTier&gt; Op NextTier &#x3D;&gt; Box::new(Expr::Op(&lt;&gt;)),
    NextTier
&#125;;

Expr &#x3D; Tier&lt;ExprOp, Factor&gt;;
Factor &#x3D; Tier&lt;FactorOp, Term&gt;;

ExprOp: Opcode &#x3D; &#123; &#x2F;&#x2F; (3)
    &quot;+&quot; &#x3D;&gt; Opcode::Add,
    &quot;-&quot; &#x3D;&gt; Opcode::Sub,
&#125;;

FactorOp: Opcode &#x3D; &#123;
    &quot;*&quot; &#x3D;&gt; Opcode::Mul,
    &quot;&#x2F;&quot; &#x3D;&gt; Opcode::Div,
&#125;;</code></pre></div><p>当然, 我们需要向 <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/main.rs">main.rs 文件</a>中添加一些测试:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[macro_use] extern crate lalrpop_util;

lalrpop_mod!(pub calculator5);

#[test]
fn calculator5() &#123;
    let expr &#x3D; calculator5::ExprsParser::new().parse(&quot;&quot;).unwrap();
    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[]&quot;);

    let expr &#x3D; calculator5::ExprsParser::new()
        .parse(&quot;22 * 44 + 66&quot;)
        .unwrap();
    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * 44) + 66)]&quot;);

    let expr &#x3D; calculator5::ExprsParser::new()
        .parse(&quot;22 * 44 + 66,&quot;)
        .unwrap();
    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * 44) + 66)]&quot;);

    let expr &#x3D; calculator5::ExprsParser::new()
        .parse(&quot;22 * 44 + 66, 13*3&quot;)
        .unwrap();
    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * 44) + 66), (13 * 3)]&quot;);

    let expr &#x3D; calculator5::ExprsParser::new()
        .parse(&quot;22 * 44 + 66, 13*3,&quot;)
        .unwrap();
    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * 44) + 66), (13 * 3)]&quot;);
&#125;</code></pre></div><md id="07"><h2 id="7-从动作代码中返回错误-Returning-errors-from-actions"><a href="#7-从动作代码中返回错误-Returning-errors-from-actions" class="headerlink" title="[7]从动作代码中返回错误|Returning errors from actions"></a>[7]从动作代码中返回错误|Returning errors from actions</h2><p>有时候,如果动作代码(ActionCode)能够返回错误而不是直接返回<code>T</code>类型的值,这会很实用. 这是因为我们通常不能仅通过语法规则拒绝所有无效输入,工作量太大.</p><p>即使是在我们的计算器示例中,您也可以看到我们正在”欺骗”系统:我们的语法接受无限位数,但它实际上会被解析为<code>i32</code>. 这是一个问题,因为<code>i32</code>可以表示的最大数字是 2147483647. 如果给它一个更大的数字,它会触发Panic,因为它只会考虑到<code>i32</code>转换成功的情况.</p><p>如果您熟悉Rust的错误处理机制,您可能会认为我们可以让<code>Num</code>返回<code>Option&lt;i32&gt;</code>甚至<code>Result&lt;i32, ...&gt;</code>,您说的对. 但是我们并不需要这样子,因为如果我们可以看看 <code>ExprParser::parse()</code>的返回类型, 它已经返回了<code>Result&lt;i32,ParseError&gt;</code>.所以我们需要的是将其”挂钩”到这个现有的错误机制,并创建可以返回错误的动作代码.</p><p>LALRPOP可以非常容易的通过定义带有 <code>=&gt;?</code> 而不是<code>=&gt;</code>的动作代码来实现这一点. 返回的值然后被假定为<code>Result&lt;T, ParseError&gt;</code>而不是简单的<code>T</code>.</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D; &#123;
    r&quot;[0-9]+&quot; &#x3D;&gt;? i32::from_str(&lt;&gt;)
        .map_err(|_| ParseError::User &#123;
            error: &quot;number is too big&quot;
        &#125;)
&#125;;</code></pre></div><p>此外,我们必须在文件的顶部添加<code>use lalrpop_util::ParseError;</code>,以便我们可以访问 <code>ParseError</code>类型. 您可以在<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator6.lalrpop">calculator6.lalrpop</a>中找到完整的代码. 这可以让你很好地处理错误:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[macro_use] extern crate lalrpop_util;

lalrpop_mod!(pub calculator6);

#[test]
fn calculator6() &#123;
    &#x2F;&#x2F; Number is one bigger than std::i32::MAX
    let expr &#x3D; calculator6::ExprsParser::new().parse(&quot;2147483648&quot;);
    assert!(expr.is_err());
&#125;</code></pre></div><p>No panics!</p><p>您甚至可以更进一步,定义您自己的错误类型,例如包含所有可能错误的枚举. 这使您可以更轻松地区分不同的错误,而不是依靠字符串.</p><p>为此,假设我们想定义两种错误:</p><ul><li>输入数字太大</li><li>输入号码不是偶数 —— 现在我们将计算器修改为仅接受偶数</li></ul><p>我们首先在 <code>main.rs</code> 中定义我们的错误枚举:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Calculator6Error &#123;
    InputTooBig,
    OddNumber,
&#125;</code></pre></div><p>然后我们将其导入我们的语法,并告诉 LALRPOP 将其用作用户错误类型,所以我们需要将文件的顶部更改为:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use std::str::FromStr;
use ast::&#123;Expr, Opcode&#125;;

use super::Calculator6Error;

use lalrpop_util::ParseError;

grammar;

extern &#123;
    type Error &#x3D; Calculator6Error;
&#125;</code></pre></div><p>我们可以通过更改 <code>Num</code> 的定义来使用我们的新错误:</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D; &#123;
    r&quot;[0-9]+&quot; &#x3D;&gt;? i32::from_str(&lt;&gt;)
        .map_err(|_| ParseError::User &#123;
            error: Calculator6Error::InputTooBig
        &#125;)
        .and_then(|i| if i % 2 &#x3D;&#x3D; 0 &#123;
            Ok(i)
        &#125; else &#123;
            Err(ParseError::User &#123;
                error: Calculator6Error::OddNumber
            &#125;)
        &#125;)
&#125;;</code></pre></div><p>最后,让我们看看效果如何:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[macro_use] extern crate lalrpop_util;

lalrpop_mod!(pub calculator6b);

#[test]
fn calculator6b() &#123;
    use lalrpop_util::ParseError;

    let expr &#x3D; calculator6b::ExprsParser::new().parse(&quot;2147483648&quot;);
    assert!(expr.is_err());
    assert_eq!(expr.unwrap_err(), ParseError::User &#123; error: Calculator6Error::InputTooBig &#125;);

    let expr &#x3D; calculator6b::ExprsParser::new().parse(&quot;3&quot;);
    assert!(expr.is_err());
    assert_eq!(expr.unwrap_err(), ParseError::User &#123; error: Calculator6Error::OddNumber &#125;);
&#125;</code></pre></div><p>太酷啦!(There we go!) 你可以在 <a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator6b.lalrpop"><code>calculator6b.lalrpop</code></a> 中找到完整代码.</p><md id="08"><h2 id="8-错误恢复-Error-recovery"><a href="#8-错误恢复-Error-recovery" class="headerlink" title="[8]错误恢复|Error recovery"></a>[8]错误恢复|Error recovery</h2><p>默认情况下,解析器遇到错误时会立即停止. 但有时我们想要尝试恢复并继续. LALRPOP 可以做到这一点,但您必须通过在语法中定义各种”错误恢复”点来帮助它. 这是通过使用特殊的<code>!</code> 符号(token)完成的:这个符号只在解析器遇到输入中的错误时出现. 当出现错误时,解析器会尝试恢复并继续; 它通过将<code>!</code>符号进入stream中,执行它可以执行的任何操作,然后丢弃输入的tokens,直到找到可以让它继续的东西.</p><p>让我们看看如何使用错误恢复来恢复在解析时遇到的多个错误. 首先,我们需要一种方式来返回多个错误,因为这不是 LALRPOP 自身做的事情,所以我们添加一个存储在解析时遇到的错误的<code>Vec</code>. 由于<code>!</code>的结果包含一个token,但错误恢复要求token可以被克隆(cloned). 我们需要用这个替换LALRPOP文件中的 “grammar” 行:</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">grammar&lt;&#39;err&gt;(errors: &amp;&#39;err mut Vec&lt;ErrorRecovery&lt;usize, Token&lt;&#39;input&gt;, &amp;&#39;static str&gt;&gt;);</code></pre></div><p>Since an alternative containing <code>!</code> is expected to return the same type of<br>value as the other alternatives in the production we add an extra variant to<br><code>Expr</code> to indicate that an error was found.</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub enum Expr &#123;
    Number(i32),
    Op(Box&lt;Expr&gt;, Opcode, Box&lt;Expr&gt;),
    Error,
&#125;</code></pre></div><p>最后,我们修改语法,添加包含<code>!</code>的第三个替代方案(alternative),它简单地将从<code>!</code>接收的<code>ErrorRecovery</code>值存储在<code>errors</code>中,并返回<code>Expr::Error</code>. 错误token的值将是一个<a target="_blank" rel="noopener" href="https://docs.rs/lalrpop-util/0.12.1/lalrpop_util/enum.ParseError.html"><code>ParseError</code>值</a>.</p><p>🌸 这是一段 lalrpop 代码 为了使其高亮以便拥有更高的可读性故标记为 Rust</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Term: Box&lt;Expr&gt; &#x3D; &#123;
    Num &#x3D;&gt; Box::new(Expr::Number(&lt;&gt;)),
    &quot;(&quot; &lt;Expr&gt; &quot;)&quot;,
    ! &#x3D;&gt; &#123; errors.push(&lt;&gt;); Box::new(Expr::Error) &#125;,
&#125;;</code></pre></div><p>现在我们可以添加包含各种错误(例如,缺少操作对象)的测试. 注意,现在<code>parse</code>方法有两个参数而不是一个,这是因为我们重写了 LALRPOP 文件中的 “grammer” 行. 您可以看到解析器通过在必要的地方插入<code>!</code>token来从缺少操作对象中恢复.</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[test]
fn calculator7() &#123;
    let mut errors &#x3D; Vec::new();

    let expr &#x3D; calculator7::ExprsParser::new()
        .parse(&amp;mut errors, &quot;22 * + 3&quot;)
        .unwrap();
    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * error) + 3)]&quot;);

    let expr &#x3D; calculator7::ExprsParser::new()
        .parse(&amp;mut errors, &quot;22 * 44 + 66, *3&quot;)
        .unwrap();
    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[((22 * 44) + 66), (error * 3)]&quot;);

    let expr &#x3D; calculator7::ExprsParser::new()
        .parse(&amp;mut errors, &quot;*&quot;)
        .unwrap();
    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;[(error * error)]&quot;);

    assert_eq!(errors.len(), 4);
&#125;</code></pre></div><md id="09"><h2 id="9-传递状态参数-Passing-state-parameter"><a href="#9-传递状态参数-Passing-state-parameter" class="headerlink" title="[9]传递状态参数|Passing state parameter"></a>[9]传递状态参数|Passing state parameter</h2><p>默认情况下, 分析器不接受除输入以外的任何参数. 在构建AST时, 可能存在需要向分析器传递参数的特殊需求.</p><p>回到<code>calculator4</code>的例子中, 我们可以向解析器传递一个参数:</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">grammar(scale: i32);</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">Num: i32 &#x3D; &#123;
    r&quot;[0-9]+&quot; &#x3D;&gt; i32::from_str(&lt;&gt;).unwrap()*scale,
&#125;;</code></pre></div><p>这里解析器将接受一个<code>scale</code>参数, 该参数将对遇到的每个数字进行缩放.</p><p>然后我们可以调用解析器传递<code>scale</code>参数 :</p><div class="code-wrapper"><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[test]
fn calculator8() &#123;
    let scale &#x3D; 2;
    let expr &#x3D; calculator8::ExprParser::new()
        .parse(scale,&quot;11 * 22 + 33&quot;)
        .unwrap();
    assert_eq!(&amp;format!(&quot;&#123;:?&#125;&quot;, expr), &quot;((22 * 44) + 66)&quot;);
&#125;</code></pre></div><p>对于使用<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/expr_arena_ast.rs">此结构</a>来构建AST的更实用的示例,请查看<a target="_blank" rel="noopener" href="https://github.com/lalrpop/lalrpop/blob/master/lalrpop-test/src/expr_arena.lalrpop">此解析器</a>.</p></md></md></md></md></md></md></md></md></md></md></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/LALRPOP/" class="category-chain-item">LALRPOP</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LALRPOP/">#LALRPOP</a> <a href="/tags/Rust/">#Rust</a> <a href="/tags/%E7%BF%BB%E8%AF%91/">#翻译</a> <a href="/tags/%E6%95%99%E7%A8%8B/">#教程</a></div></div><div class="license-box my-3"><div class="license-title"><div>LALRPOP Tutorial 教程/文档-中文翻译 | LALRPOP Tutorial Chinese Book | LALRPOP是Rust写的解析器生成器</div><div>http://yuhanawa.github.io/posts/2023/57877/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Yuhanawa</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年1月25日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/2023/6de6/" title="高中模拟选课工具_高考选科分班_志愿填报工具_2024大学高校专业选课要求"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">高中模拟选课工具_高考选科分班_志愿填报工具_2024大学高校专业选课要求</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/2023/21239/" title="LALRPOP 高级设置 文档/教程-中文翻译 | LALRPOP Advanced setup"><span class="hidden-mobile">LALRPOP 高级设置 文档/教程-中文翻译 | LALRPOP Advanced setup</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.4.16/Valine.min.js",(function(){var i=Object.assign({appId:"sbyNAuxQBqjq3uoMduSWbIhb-gzGzoHsz",appKey:"pCKWRQnCJ9vokdYUmvsWlrLw",path:"window.location.pathname",placeholder:"发一条友善的评论吧...",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://sbynauxq.lc-cn-n1-shared.com",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/yuhanawa" target="_blank" rel="nofollow noopener"><span>Yuhanawa</span></a><div style="font-size:smaller"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span></div></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/prism/1.26.0/components/prism-core.min.js"></script><script src="https://lib.baomitu.com/prism/1.26.0/plugins/autoloader/prism-autoloader.min.js"></script><script src="https://lib.baomitu.com/prism/1.26.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){var e=CONFIG.code_language.enable&&CONFIG.code_language.default,a=CONFIG.copy_btn;if(e||a){var i="";i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each((function(){var n=jQuery(this);if(!(n.find("code.mermaid").length>0||n.find("span.line").length>0)){var t,c="";e&&(c=CONFIG.code_language.default,n[0].children.length>0&&n[0].children[0].classList.length>=2&&n.children().hasClass("hljs")?c=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?c=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&n[0].children.length>0&&n[0].children[0].classList.length>=2?(c=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),c=c.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",c).replace('code-widget">',(t=n[0],(Fluid.utils.getBackgroundLightness(t)>=0?"code-widget-light":"code-widget-dark")+(a?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),a&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",(function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,i=0;i<a.length;i++)if("CODE"===a[i].tagName)return a[i]}}).on("success",(function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout((function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")}),2e3)}))}))}}))}}()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/custom.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>